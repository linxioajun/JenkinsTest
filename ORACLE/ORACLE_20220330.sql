-- 分割线
SELECT HOUR, INTRADAY, EXTRADAY FROM BSLN_TIMEGROUPS;

-- 分割线
SELECT pol_name, pol# FROM lbacsys.ols$pol;

-- 分割线
UPDATE BSLN_STATISTICS S SET COMPUTE_DATE = :B18 ,SAMPLE_COUNT = :B17 ,AVERAGE = :B16 ,MINIMUM = :B15 ,MAXIMUM = :B14 ,SDEV = :B13 ,PCTILE_25 = :B12 ,PCTILE_50 = :B11 ,PCTILE_75 = :B10 ,PCTILE_90 = :B9 ,PCTILE_95 = :B8 ,PCTILE_99 = :B7 ,EST_SAMPLE_COUNT = :B6 ,EST_SLOPE = :B5 ,EST_INTERCEPT = :B4 ,EST_FIT_QUALITY = :B3 ,EST_PCTILE_999 = :B2 ,EST_PCTILE_9999 = :B1 WHERE S.BSLN_GUID = :B21 AND S.METRIC_ID = :B20 AND S.TIMEGROUP = :B19 ;

-- 分割线
SELECT END_INTERVAL_TIME FROM DBA_HIST_SNAPSHOT WHERE DBID = :B2 AND SNAP_ID = :B1 AND ROWNUM = 1;

-- 分割线
UPDATE BSLN_BASELINES SET LAST_COMPUTE_DATE = :B2 WHERE BSLN_GUID = :B1 ;

-- 分割线，错误的SQL
SELECT COUNT(*) FRON CLOUD;

-- 分割线
INSERT INTO BSLN_STATISTICS (BSLN_GUID ,METRIC_ID ,COMPUTE_DATE ,TIMEGROUPING ,TIMEGROUP ,SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ) SELECT B.BSLN_GUID ,MD.METRIC_ID ,:B5 ,:B4 ,:B3 ,SUM(SS.NUM_INTERVAL) ,CASE WHEN SUM(SS.NUM_INTERVAL) > 0 THEN SUM(SS.AVERAGE*SS.NUM_INTERVAL)/SUM(SS.NUM_INTERVAL) ELSE TO_NUMBER(NULL) END ,MIN(SS.MINVAL) ,MAX(SS.MAXVAL) ,CASE WHEN SUM(SS.NUM_INTERVAL) = 1 THEN 0 WHEN SUM(SS.NUM_INTERVAL) < 1 OR (SUM(SS.SUM_SQUARES) - (SUM(SS.NUM_INTERVAL*SS.AVERAGE)* SUM(SS.NUM_INTERVAL*SS.AVERAGE)/ SUM(SS.NUM_INTERVAL)))/ (SUM(SS.NUM_INTERVAL)-1) < 0 THEN NULL ELSE SQRT((SUM(SS.SUM_SQUARES) - (SUM(SS.NUM_INTERVAL*SS.AVERAGE)* SUM(SS.NUM_INTERVAL*SS.AVERAGE)/ SUM(SS.NUM_INTERVAL)))/ (SUM(SS.NUM_INTERVAL)-1)) END FROM BSLN_BASELINES B ,DBA_HIST_BASELINE AB ,DBA_HIST_SNAPSHOT SN ,DBA_HIST_DATABASE_INSTANCE DI ,SYS.WRH$_SYSMETRIC_SUMMARY SS ,BSLN_METRIC_DEFAULTS MD WHERE B.BSLN_GUID = :B2 AND AB.DBID = B.DBID AND AB.BASELINE_ID = B.BASELINE_ID AND SN.DBID = AB.DBID AND SN.SNAP_ID BETWEEN AB.START_SNAP_ID AND AB.END_SNAP_ID AND DI.DBID = SN.DBID AND DI.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND DI.STARTUP_TIME = SN.STARTUP_TIME AND DI.INSTANCE_NAME = B.INSTANCE_NAME AND SS.SNAP_ID = SN.SNAP_ID AND SS.DBID = SN.DBID AND SS.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND SS.GROUP_ID = 2 AND SS.METRIC_ID = MD.METRIC_ID AND MD.STATUS = :B1 GROUP BY B.BSLN_GUID ,MD.METRIC_ID;

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(C1,0), NVL(C2,0), NVL(C3,0) FROM (SELECT /*+ qb_name("innerQuery") INDEX( "SH" "WRH$_SYSMETRIC_HISTORY_INDEX")  */ COUNT(*) AS C1, 4294967295 AS C2, SUM(CASE WHEN ("SH"."GROUP_ID"=2) THEN 1 ELSE 0 END) AS C3  FROM "SYS"."WRH$_SYSMETRIC_HISTORY" "SH" WHERE ("SH"."DBID"=:B1) AND ("SH"."SNAP_ID">=:B2) AND ("SH"."SNAP_ID"<=:B3)) innerQuery;

-- 分割线
SELECT BEGIN_INTERVAL_TIME FROM DBA_HIST_SNAPSHOT WHERE DBID = :B2 AND SNAP_ID = :B1 AND ROWNUM = 1;

-- 分割线
/* SQL Analyze(1) */ select /*+  full(t)    no_parallel(t) no_parallel_index(t) dbms_stats cursor_sharing_exact use_weak_name_resl dynamic_sampling(0) no_monitoring xmlindex_sel_idx_tbl opt_param('optimizer_inmemory_aware' 'false') no_substrb_pad  */to_char(count("DBID")),substrb(dump(min("DBID"),16,0,64),1,240),substrb(dump(max("DBID"),16,0,64),1,240),to_char(count("INSTANCE_NAME")),substrb(dump(min("INSTANCE_NAME"),16,0,64),1,240),substrb(dump(max("INSTANCE_NAME"),16,0,64),1,240),to_char(count("BASELINE_ID")),substrb(dump(min("BASELINE_ID"),16,0,64),1,240),substrb(dump(max("BASELINE_ID"),16,0,64),1,240),to_char(count("BSLN_GUID")),substrb(dump(min("BSLN_GUID"),16,0,64),1,240),substrb(dump(max("BSLN_GUID"),16,0,64),1,240),to_char(count("TIMEGROUPING")),substrb(dump(min("TIMEGROUPING"),16,0,64),1,240),substrb(dump(max("TIMEGROUPING"),16,0,64),1,240),to_char(count("AUTO_TIMEGROUP")),substrb(dump(min("AUTO_TIMEGROUP"),16,0,64),1,240),substrb(dump(max("AUTO_TIMEGROUP"),16,0,64),1,240),to_char(count("STATUS")),substrb(dump(min("STATUS"),16,0,64),1,240),substrb(dump(max("STATUS"),16,0,64),1,240),to_char(count("LAST_COMPUTE_DATE")),substrb(dump(min("LAST_COMPUTE_DATE"),16,0,64),1,240),substrb(dump(max("LAST_COMPUTE_DATE"),16,0,64),1,240),count(rowidtochar(rowid)) from "DBSNMP"."BSLN_BASELINES" t  /* TOPN,NIL,NIL,TOPN,NIL,NIL,TOPN,NIL,NIL,ACL,NIL,NIL,NDV,NIL,NIL,TOPN,NIL,NIL,TOPN,NIL,NIL,NDV,NIL,NIL,RWID,U254,U254,U254,U254,U254,U254,U254,U254U*/;

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "BST")  */ 1 AS C1 FROM "SYS"."WRM$_BASELINE_DETAILS" "BST") innerQuery;

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "WRM$_SNAPSHOT#3")  */ 1 AS C1 FROM "SYS"."WRM$_SNAPSHOT" "WRM$_SNAPSHOT#3", "SYS"."WRM$_DATABASE_INSTANCE" "WRM$_DATABASE_INSTANCE#2" WHERE ("WRM$_DATABASE_INSTANCE#2"."INSTANCE_NAME"=:B1) AND ("WRM$_DATABASE_INSTANCE#2"."DBID"=:B2) AND ("WRM$_SNAPSHOT#3"."DBID"=:B3) AND ("WRM$_DATABASE_INSTANCE#2"."DBID"="WRM$_SNAPSHOT#3"."DBID") AND ("WRM$_DATABASE_INSTANCE#2"."INSTANCE_NUMBER"="WRM$_SNAPSHOT#3"."INSTANCE_NUMBER") AND ("WRM$_DATABASE_INSTANCE#2"."STARTUP_TIME"="WRM$_SNAPSHOT#3"."STARTUP_TIME") AND ("WRM$_SNAPSHOT#3"."STATUS"=0) AND ("WRM$_SNAPSHOT#3"."SNAP_ID">=:B4) AND ("WRM$_SNAPSHOT#3"."SNAP_ID"<=:B5)) innerQuery;

-- 分割线
SELECT DISTINCT(X.BSLN_GUID) GUID FROM TABLE(CAST(:B1 AS BSLN_VARIANCE_SET)) X;

-- 分割线
WITH NONTIMEGROUPED_RAWDATA AS (SELECT MD.METRIC_ID ,SH.END_TIME AS OBS_TIME ,SH.VALUE AS OBS_VALUE FROM DBA_HIST_SNAPSHOT SN ,DBA_HIST_DATABASE_INSTANCE DI ,SYS.WRH$_SYSMETRIC_HISTORY SH ,BSLN_METRIC_DEFAULTS MD WHERE SN.DBID = :B5 AND SN.SNAP_ID BETWEEN :B4 AND :B3 AND DI.DBID = SN.DBID AND DI.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND DI.STARTUP_TIME = SN.STARTUP_TIME AND DI.INSTANCE_NAME = :B2 AND SH.SNAP_ID = SN.SNAP_ID AND SH.DBID = SN.DBID AND SH.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND SH.GROUP_ID = 2 AND SH.METRIC_ID = MD.METRIC_ID AND MD.STATUS = :B1 ) SELECT BSLN_STATISTICS_T (:B12 ,METRIC_ID ,:B11 ,:B10 ,:B9 ||':'||:B9 ,SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 ,EST_SAMPLE_COUNT ,EST_SLOPE ,EST_INTERCEPT ,CASE WHEN EST_SLOPE = 0 THEN 0 ELSE GREATEST(0,NVL(100-(25*POWER((1-EST_MU1/EST_SLOPE), 2)*(EST_SAMPLE_COUNT-1) ),0)) END ,LN( 1000) * EST_SLOPE + EST_INTERCEPT ,LN(10000) * EST_SLOPE + EST_INTERCEPT ) FROM (SELECT METRIC_ID ,EST_MU AS EST_SLOPE ,EST_MU * LN(ALPHA) + X_M AS EST_INTERCEPT ,TO_NUMBER(NULL) AS EST_FIT_QUALITY ,CASE WHEN COUNT_BELOW_X_J > 0 THEN (SUM_BELOW_X_J + (N-M+1)*(X_J-X_M))/COUNT_BELOW_X_J - X_J ELSE TO_NUMBER(NULL) END AS EST_MU1 ,EST_SAMPLE_COUNT ,N AS SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 FROM (SELECT METRIC_ID ,MAX(N) AS N ,COUNT(RRANK) AS EST_SAMPLE_COUNT ,CASE WHEN COUNT(RRANK) > 3 THEN ( SUM(OBS_VALUE) + ( MAX(N) - MAX(RRANK) ) * MAX(OBS_VALUE) - (MAX(N) - MIN(RRANK) + 1) * MIN(OBS_VALUE) ) / (COUNT(RRANK)-1) ELSE TO_NUMBER(NULL) END AS EST_MU ,(MAX(N) - MIN(RRANK) + 1) / (MAX(N) + 1) AS ALPHA ,MIN(OBS_VALUE) AS X_M ,MAX(OBS_VALUE) AS X_L ,MAX(RRANK) AS L ,MIN(RRANK) AS M ,MAX(MID_TAIL_VALUE) AS X_J ,SUM(CASE WHEN OBS_VALUE < MID_TAIL_VALUE THEN OBS_VALUE ELSE 0 END ) AS SUM_BELOW_X_J ,SUM(CASE WHEN CUME_DIST < :B6 THEN 1 ELSE 0 END ) AS COUNT_BELOW_X_J ,MAX(MAX_VAL) AS MAXIMUM ,MAX(MIN_VAL) AS MINIMUM ,MAX(AVG_VAL) AS AVERAGE ,MAX(SDEV_VAL) AS SDEV ,MAX(PCTILE_25) AS PCTILE_25 ,MAX(PCTILE_50) AS PCTILE_50 ,MAX(PCTILE_75) AS PCTILE_75 ,MAX(PCTILE_90) AS PCTILE_90 ,MAX(PCTILE_95) AS PCTILE_95 ,MAX(PCTILE_99) AS PCTILE_99 FROM (SELECT METRIC_ID ,OBS_VALUE AS OBS_VALUE ,CUME_DIST () OVER (PARTITION BY METRIC_ID ORDER BY OBS_VALUE ) AS CUME_DIST ,COUNT(1) OVER (PARTITION BY METRIC_ID ) AS N ,ROW_NUMBER () OVER (PARTITION BY METRIC_ID ORDER BY OBS_VALUE) AS RRANK ,PERCENTILE_DISC(:B6 ) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS MID_TAIL_VALUE ,MAX(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS MAX_VAL ,MIN(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS MIN_VAL ,AVG(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS AVG_VAL ,STDDEV(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS SDEV_VAL ,PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_25 ,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_50 ,PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_75 ,PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_90 ,PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_95 ,PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_99 FROM NONTIMEGROUPED_RAWDATA D ) X WHERE X.CUME_DIST >= :B8 AND X.CUME_DIST <= :B7 GROUP BY METRIC_ID ));

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "BL")  */ 1 AS C1 FROM "SYS"."WRM$_BASELINE" "BL" WHERE ("BL"."DBID"=:B1) AND ("BL"."BASELINE_ID"=:B2) AND ("BL"."BASELINE_ID"<>0)) innerQuery;

-- 分割线
/* SQL Analyze(1) */ select /*+  full(t)    no_parallel(t) no_parallel_index(t) dbms_stats cursor_sharing_exact use_weak_name_resl dynamic_sampling(0) no_monitoring xmlindex_sel_idx_tbl opt_param('optimizer_inmemory_aware' 'false') no_substrb_pad  */to_char(count("PROXY_SESSIONID")),substrb(dump(min("PROXY_SESSIONID"),16,0,64),1,240),substrb(dump(max("PROXY_SESSIONID"),16,0,64),1,240),to_char(count("OS_USER")),substrb(dump(min("OS_USER"),16,0,64),1,240),substrb(dump(max("OS_USER"),16,0,64),1,240),to_char(count("HOST_NAME")),substrb(dump(min("HOST_NAME"),16,0,64),1,240),substrb(dump(max("HOST_NAME"),16,0,64),1,240),to_char(count("TERMINAL")),substrb(dump(min("TERMINAL"),16,0,64),1,240),substrb(dump(max("TERMINAL"),16,0,64),1,240),to_char(count("INSTANCE_ID")),substrb(dump(min("INSTANCE_ID"),16,0,64),1,240),substrb(dump(max("INSTANCE_ID"),16,0,64),1,240),to_char(count("DBID")),substrb(dump(min("DBID"),16,0,64),1,240),substrb(dump(max("DBID"),16,0,64),1,240),to_char(count("AUTHENTICATION_TYPE")),substrb(dump(min("AUTHENTICATION_TYPE"),16,0,64),1,240),substrb(dump(max("AUTHENTICATION_TYPE"),16,0,64),1,240),to_char(count("USERID")),substrb(dump(min("USERID"),16,0,64),1,240),substrb(dump(max("USERID"),16,0,64),1,240),to_char(count("PROXY_USERID")),substrb(dump(min("PROXY_USERID"),16,0,64),1,240),substrb(dump(max("PROXY_USERID"),16,0,64),1,240),to_char(count("EXTERNAL_USERID")),substrb(dump(min("EXTERNAL_USERID"),16,0,64),1,240),substrb(dump(max("EXTERNAL_USERID"),16,0,64),1,240),to_char(count("GLOBAL_USERID")),substrb(dump(min("GLOBAL_USERID"),16,0,64),1,240),substrb(dump(max("GLOBAL_USERID"),16,0,64),1,240),to_char(count("CLIENT_PROGRAM_NAME")),substrb(dump(min("CLIENT_PROGRAM_NAME"),16,0,64),1,240),substrb(dump(max("CLIENT_PROGRAM_NAME"),16,0,64),1,240),to_char(count("DBLINK_INFO")),substrb(dump(min("DBLINK_INFO"),16,0,64),1,240),substrb(dump(max("DBLINK_INFO"),16,0,64),1,240),to_char(count("XS_USER_NAME")),substrb(dump(min("XS_USER_NAME"),16,0,64),1,240),substrb(dump(max("XS_USER_NAME"),16,0,64),1,240),to_char(count("XS_SESSIONID")),substrb(dump(min("XS_SESSIONID"),16,0,64),1,240),substrb(dump(max("XS_SESSIONID"),16,0,64),1,240),to_char(count("ENTRY_ID")),substrb(dump(min("ENTRY_ID"),16,0,64),1,240),substrb(dump(max("ENTRY_ID"),16,0,64),1,240),to_char(count("STATEMENT_ID")),substrb(dump(min("STATEMENT_ID"),16,0,64),1,240),substrb(dump(max("STATEMENT_ID"),16,0,64),1,240),to_char(count("EVENT_TIMESTAMP")),substrb(dump(min("EVENT_TIMESTAMP"),16,0,64),1,240),substrb(dump(max("EVENT_TIMESTAMP"),16,0,64),1,240),to_char(count("ACTION")),substrb(dump(min("ACTION"),16,0,64),1,240),substrb(dump(max("ACTION"),16,0,64),1,240),to_char(count("RETURN_CODE")),substrb(dump(min("RETURN_CODE"),16,0,64),1,240),substrb(dump(max("RETURN_CODE"),16,0,64),1,240),to_char(count("OS_PROCESS")),substrb(dump(min("OS_PROCESS"),16,0,64),1,240),substrb(dump(max("OS_PROCESS"),16,0,64),1,240),to_char(count("TRANSACTION_ID")),substrb(dump(min("TRANSACTION_ID"),16,0,64),1,240),substrb(dump(max("TRANSACTION_ID"),16,0,64),1,240),to_char(count("SCN")),substrb(dump(min("SCN"),16,0,64),1,240),substrb(dump(max("SCN"),16,0,64),1,240),to_char(count("EXECUTION_ID")),substrb(dump(min("EXECUTION_ID"),16,0,64),1,240),substrb(dump(max("EXECUTION_ID"),16,0,64),1,240),to_char(count("OBJ_OWNER")),substrb(dump(min("OBJ_OWNER"),16,0,64),1,240),substrb(dump(max("OBJ_OWNER"),16,0,64),1,240),to_char(count("OBJ_NAME")),substrb(dump(min("OBJ_NAME"),16,0,64),1,240),substrb(dump(max("OBJ_NAME"),16,0,64),1,240),to_char(count(case when "SQL_TEXT" is null then null else 1 end)),to_char(count(case when "SQL_BINDS" is null then null else 1 end)),to_char(count("APPLICATION_CONTEXTS")),substrb(dump(min("APPLICATION_CONTEXTS"),16,0,64),1,240),substrb(dump(max("APPLICATION_CONTEXTS"),16,0,64),1,240),to_char(count("CLIENT_IDENTIFIER")),substrb(dump(min("CLIENT_IDENTIFIER"),16,0,64),1,240),substrb(dump(max("CLIENT_IDENTIFIER"),16,0,64),1,240),to_char(count("NEW_OWNER")),substrb(dump(min("NEW_OWNER"),16,0,64),1,240),substrb(dump(max("NEW_OWNER"),16,0,64),1,240),to_char(count("NEW_NAME")),substrb(dump(min("NEW_NAME"),16,0,64),1,240),substrb(dump(max("NEW_NAME"),16,0,64),1,240),to_char(count("OBJECT_EDITION")),substrb(dump(min("OBJECT_EDITION"),16,0,64),1,240),substrb(dump(max("OBJECT_EDITION"),16,0,64),1,240),to_char(count("SYSTEM_PRIVILEGE_USED")),substrb(dump(min("SYSTEM_PRIVILEGE_USED"),16,0,64),1,240),substrb(dump(max("SYSTEM_PRIVILEGE_USED"),16,0,64),1,240),to_char(count("SYSTEM_PRIVILEGE")),substrb(dump(min("SYSTEM_PRIVILEGE"),16,0,64),1,240),substrb(dump(max("SYSTEM_PRIVILEGE"),16,0,64),1,240),to_char(count("AUDIT_OPTION")),substrb(dump(min("AUDIT_OPTION"),16,0,64),1,240),substrb(dump(max("AUDIT_OPTION"),16,0,64),1,240),to_char(count("OBJECT_PRIVILEGES")),substrb(dump(min("OBJECT_PRIVILEGES"),16,0,64),1,240),substrb(dump(max("OBJECT_PRIVILEGES"),16,0,64),1,240),to_char(count("ROLE")),substrb(dump(min("ROLE"),16,0,64),1,240),substrb(dump(max("ROLE"),16,0,64),1,240),to_char(count("TARGET_USER")),substrb(dump(min("TARGET_USER"),16,0,64),1,240),substrb(dump(max("TARGET_USER"),16,0,64),1,240),to_char(count("EXCLUDED_USER")),substrb(dump(min("EXCLUDED_USER"),16,0,64),1,240),substrb(dump(max("EXCLUDED_USER"),16,0,64),1,240),to_char(count("EXCLUDED_SCHEMA")),substrb(dump(min("EXCLUDED_SCHEMA"),16,0,64),1,240),substrb(dump(max("EXCLUDED_SCHEMA"),16,0,64),1,240),to_char(count("EXCLUDED_OBJECT")),substrb(dump(min("EXCLUDED_OBJECT"),16,0,64),1,240),substrb(dump(max("EXCLUDED_OBJECT"),16,0,64),1,240),to_char(count("CURRENT_USER")),substrb(dump(min("CURRENT_USER"),16,0,64),1,240),substrb(dump(max("CURRENT_USER"),16,0,64),1,240),to_char(count("ADDITIONAL_INFO")),substrb(dump(min("ADDITIONAL_INFO"),16,0,64),1,240),substrb(dump(max("ADDITIONAL_INFO"),16,0,64),1,240),to_char(count("UNIFIED_AUDIT_POLICIES")),substrb(dump(min("UNIFIED_AUDIT_POLICIES"),16,0,64),1,240),substrb(dump(max("UNIFIED_AUDIT_POLICIES"),16,0,64),1,240),to_char(count("FGA_POLICY_NAME")),substrb(dump(min("FGA_POLICY_NAME"),16,0,64),1,240),substrb(dump(max("FGA_POLICY_NAME"),16,0,64),1,240),to_char(count("XS_INACTIVITY_TIMEOUT")),substrb(dump(min("XS_INACTIVITY_TIMEOUT"),16,0,64),1,240),substrb(dump(max("XS_INACTIVITY_TIMEOUT"),16,0,64),1,240),to_char(count("XS_ENTITY_TYPE")),substrb(dump(min("XS_ENTITY_TYPE"),16,0,64),1,240),substrb(dump(max("XS_ENTITY_TYPE"),16,0,64),1,240),to_char(count("XS_TARGET_PRINCIPAL_NAME")),substrb(dump(min("XS_TARGET_PRINCIPAL_NAME"),16,0,64),1,240),substrb(dump(max("XS_TARGET_PRINCIPAL_NAME"),16,0,64),1,240),to_char(count("XS_PROXY_USER_NAME")),substrb(dump(min("XS_PROXY_USER_NAME"),16,0,64),1,240),substrb(dump(max("XS_PROXY_USER_NAME"),16,0,64),1,240),to_char(count("XS_DATASEC_POLICY_NAME")),substrb(dump(min("XS_DATASEC_POLICY_NAME"),16,0,64),1,240),substrb(dump(max("XS_DATASEC_POLICY_NAME"),16,0,64),1,240),to_char(count("XS_SCHEMA_NAME")),substrb(dump(min("XS_SCHEMA_NAME"),16,0,64),1,240),substrb(dump(max("XS_SCHEMA_NAME"),16,0,64),1,240),to_char(count("XS_CALLBACK_EVENT_TYPE")),substrb(dump(min("XS_CALLBACK_EVENT_TYPE"),16,0,64),1,240),substrb(dump(max("XS_CALLBACK_EVENT_TYPE"),16,0,64),1,240),to_char(count("XS_PACKAGE_NAME")),substrb(dump(min("XS_PACKAGE_NAME"),16,0,64),1,240),substrb(dump(max("XS_PACKAGE_NAME"),16,0,64),1,240),to_char(count("XS_PROCEDURE_NAME")),substrb(dump(min("XS_PROCEDURE_NAME"),16,0,64),1,240),substrb(dump(max("XS_PROCEDURE_NAME"),16,0,64),1,240),to_char(count("XS_ENABLED_ROLE")),substrb(dump(min("XS_ENABLED_ROLE"),16,0,64),1,240),substrb(dump(max("XS_ENABLED_ROLE"),16,0,64),1,240),to_char(count("XS_COOKIE")),substrb(dump(min("XS_COOKIE"),16,0,64),1,240),substrb(dump(max("XS_COOKIE"),16,0,64),1,240),to_char(count("XS_NS_NAME")),substrb(dump(min("XS_NS_NAME"),16,0,64),1,240),substrb(dump(max("XS_NS_NAME"),16,0,64),1,240),to_char(count("XS_NS_ATTRIBUTE")),substrb(dump(min("XS_NS_ATTRIBUTE"),16,0,64),1,240),substrb(dump(max("XS_NS_ATTRIBUTE"),16,0,64),1,240),to_char(count("XS_NS_ATTRIBUTE_OLD_VAL")),substrb(dump(min("XS_NS_ATTRIBUTE_OLD_VAL"),16,0,64),1,240),substrb(dump(max("XS_NS_ATTRIBUTE_OLD_VAL"),16,0,64),1,240),to_char(count("XS_NS_ATTRIBUTE_NEW_VAL")),substrb(dump(min("XS_NS_ATTRIBUTE_NEW_VAL"),16,0,64),1,240),substrb(dump(max("XS_NS_ATTRIBUTE_NEW_VAL"),16,0,64),1,240),to_char(count("DV_ACTION_CODE")),substrb(dump(min("DV_ACTION_CODE"),16,0,64),1,240),substrb(dump(max("DV_ACTION_CODE"),16,0,64),1,240),to_char(count("DV_ACTION_NAME")),substrb(dump(min("DV_ACTION_NAME"),16,0,64),1,240),substrb(dump(max("DV_ACTION_NAME"),16,0,64),1,240),to_char(count("DV_EXTENDED_ACTION_CODE")),substrb(dump(min("DV_EXTENDED_ACTION_CODE"),16,0,64),1,240),substrb(dump(max("DV_EXTENDED_ACTION_CODE"),16,0,64),1,240),to_char(count("DV_GRANTEE")),substrb(dump(min("DV_GRANTEE"),16,0,64),1,240),substrb(dump(max("DV_GRANTEE"),16,0,64),1,240),to_char(count("DV_RETURN_CODE")),substrb(dump(min("DV_RETURN_CODE"),16,0,64),1,240),substrb(dump(max("DV_RETURN_CODE"),16,0,64),1,240),to_char(count("DV_ACTION_OBJECT_NAME")),substrb(dump(min("DV_ACTION_OBJECT_NAME"),16,0,64),1,240),substrb(dump(max("DV_ACTION_OBJECT_NAME"),16,0,64),1,240),to_char(count("DV_RULE_SET_NAME")),substrb(dump(min("DV_RULE_SET_NAME"),16,0,64),1,240),substrb(dump(max("DV_RULE_SET_NAME"),16,0,64),1,240),to_char(count("DV_COMMENT")),substrb(dump(min("DV_COMMENT"),16,0,64),1,240),substrb(dump(max("DV_COMMENT"),16,0,64),1,240),to_char(count("DV_FACTOR_CONTEXT")),substrb(dump(min("DV_FACTOR_CONTEXT"),16,0,64),1,240),substrb(dump(max("DV_FACTOR_CONTEXT"),16,0,64),1,240),to_char(count("DV_OBJECT_STATUS")),substrb(dump(min("DV_OBJECT_STATUS"),16,0,64),1,240),substrb(dump(max("DV_OBJECT_STATUS"),16,0,64),1,240),to_char(count("OLS_POLICY_NAME")),substrb(dump(min("OLS_POLICY_NAME"),16,0,64),1,240),substrb(dump(max("OLS_POLICY_NAME"),16,0,64),1,240),to_char(count("OLS_GRANTEE")),substrb(dump(min("OLS_GRANTEE"),16,0,64),1,240),substrb(dump(max("OLS_GRANTEE"),16,0,64),1,240),to_char(count("OLS_MAX_READ_LABEL")),substrb(dump(min("OLS_MAX_READ_LABEL"),16,0,64),1,240),substrb(dump(max("OLS_MAX_READ_LABEL"),16,0,64),1,240),to_char(count("OLS_MAX_WRITE_LABEL")),substrb(dump(min("OLS_MAX_WRITE_LABEL"),16,0,64),1,240),substrb(dump(max("OLS_MAX_WRITE_LABEL"),16,0,64),1,240),to_char(count("OLS_MIN_WRITE_LABEL")),substrb(dump(min("OLS_MIN_WRITE_LABEL"),16,0,64),1,240),substrb(dump(max("OLS_MIN_WRITE_LABEL"),16,0,64),1,240),to_char(count("OLS_PRIVILEGES_GRANTED")),substrb(dump(min("OLS_PRIVILEGES_GRANTED"),16,0,64),1,240),substrb(dump(max("OLS_PRIVILEGES_GRANTED"),16,0,64),1,240),to_char(count("OLS_PROGRAM_UNIT_NAME")),substrb(dump(min("OLS_PROGRAM_UNIT_NAME"),16,0,64),1,240),substrb(dump(max("OLS_PROGRAM_UNIT_NAME"),16,0,64),1,240),to_char(count("OLS_PRIVILEGES_USED")),substrb(dump(min("OLS_PRIVILEGES_USED"),16,0,64),1,240),substrb(dump(max("OLS_PRIVILEGES_USED"),16,0,64),1,240),to_char(count("OLS_STRING_LABEL")),substrb(dump(min("OLS_STRING_LABEL"),16,0,64),1,240),substrb(dump(max("OLS_STRING_LABEL"),16,0,64),1,240),to_char(count("OLS_LABEL_COMPONENT_TYPE")),substrb(dump(min("OLS_LABEL_COMPONENT_TYPE"),16,0,64),1,240),substrb(dump(max("OLS_LABEL_COMPONENT_TYPE"),16,0,64),1,240),to_char(count("OLS_LABEL_COMPONENT_NAME")),substrb(dump(min("OLS_LABEL_COMPONENT_NAME"),16,0,64),1,240),substrb(dump(max("OLS_LABEL_COMPONENT_NAME"),16,0,64),1,240),to_char(count("OLS_PARENT_GROUP_NAME")),substrb(dump(min("OLS_PARENT_GROUP_NAME"),16,0,64),1,240),substrb(dump(max("OLS_PARENT_GROUP_NAME"),16,0,64),1,240),to_char(count("OLS_OLD_VALUE")),substrb(dump(min("OLS_OLD_VALUE"),16,0,64),1,240),substrb(dump(max("OLS_OLD_VALUE"),16,0,64),1,240),to_char(count("OLS_NEW_VALUE")),substrb(dump(min("OLS_NEW_VALUE"),16,0,64),1,240),substrb(dump(max("OLS_NEW_VALUE"),16,0,64),1,240),to_char(count("RMAN_SESSION_RECID")),substrb(dump(min("RMAN_SESSION_RECID"),16,0,64),1,240),substrb(dump(max("RMAN_SESSION_RECID"),16,0,64),1,240),to_char(count("RMAN_SESSION_STAMP")),substrb(dump(min("RMAN_SESSION_STAMP"),16,0,64),1,240),substrb(dump(max("RMAN_SESSION_STAMP"),16,0,64),1,240),to_char(count("RMAN_OPERATION")),substrb(dump(min("RMAN_OPERATION"),16,0,64),1,240),substrb(dump(max("RMAN_OPERATION"),16,0,64),1,240),to_char(count("RMAN_OBJECT_TYPE")),substrb(dump(min("RMAN_OBJECT_TYPE"),16,0,64),1,240),substrb(dump(max("RMAN_OBJECT_TYPE"),16,0,64),1,240),to_char(count("RMAN_DEVICE_TYPE")),substrb(dump(min("RMAN_DEVICE_TYPE"),16,0,64),1,240),substrb(dump(max("RMAN_DEVICE_TYPE"),16,0,64),1,240),to_char(count("DP_TEXT_PARAMETERS1")),substrb(dump(min("DP_TEXT_PARAMETERS1"),16,0,64),1,240),substrb(dump(max("DP_TEXT_PARAMETERS1"),16,0,64),1,240),to_char(count("DP_BOOLEAN_PARAMETERS1")),substrb(dump(min("DP_BOOLEAN_PARAMETERS1"),16,0,64),1,240),substrb(dump(max("DP_BOOLEAN_PARAMETERS1"),16,0,64),1,240),to_char(count("DIRECT_PATH_NUM_COLUMNS_LOADED")),substrb(dump(min("DIRECT_PATH_NUM_COLUMNS_LOADED"),16,0,64),1,240),substrb(dump(max("DIRECT_PATH_NUM_COLUMNS_LOADED"),16,0,64),1,240),to_char(count(case when "RLS_INFO" is null then null else 1 end)),to_char(count("KSACL_USER_NAME")),substrb(dump(min("KSACL_USER_NAME"),16,0,64),1,240),substrb(dump(max("KSACL_USER_NAME"),16,0,64),1,240),to_char(count("KSACL_SERVICE_NAME")),substrb(dump(min("KSACL_SERVICE_NAME"),16,0,64),1,240),substrb(dump(max("KSACL_SERVICE_NAME"),16,0,64),1,240),to_char(count("KSACL_SOURCE_LOCATION")),substrb(dump(min("KSACL_SOURCE_LOCATION"),16,0,64),1,240),substrb(dump(max("KSACL_SOURCE_LOCATION"),16,0,64),1,240),to_char(count("CON_ID")),substrb(dump(min("CON_ID"),16,0,64),1,240),substrb(dump(max("CON_ID"),16,0,64),1,240),to_char(count("INST_ID")),substrb(dump(min("INST_ID"),16,0,64),1,240),substrb(dump(max("INST_ID"),16,0,64),1,240),to_char(count("AUDIT_TYPE")),substrb(dump(min("AUDIT_TYPE"),16,0,64),1,240),substrb(dump(max("AUDIT_TYPE"),16,0,64),1,240),to_char(count("SESSIONID")),substrb(dump(min("SESSIONID"),16,0,64),1,240),substrb(dump(max("SESSIONID"),16,0,64),1,240) from "AUDSYS"."AUD$UNIFIED" t  where TBL$OR$IDX$PART$NUM("AUDSYS"."AUD$UNIFIED",0,4,0,"ROWID") = :objn /* NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,ACL,ACL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,ACL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL*/;

-- 分割线
SELECT DDLID FROM DDLID$;

-- 分割线
INSERT INTO BSLN_STATISTICS VALUES (:B1 ,:B2 ,:B3 ,:B4 ,:B5 ,:B6 ,:B7 ,:B8 ,:B9 ,:B10 ,:B11 ,:B12 ,:B13 ,:B14 ,:B15 ,:B16 ,:B17 ,:B18 ,:B19 ,:B20 ,:B21 ,:B22 );

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "BL")  */ 1 AS C1 FROM "SYS"."WRM$_BASELINE" "BL" WHERE ("BL"."BASELINE_ID"=0) AND ("BL"."DBID"=:B1)) innerQuery;

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "BL")  */ 1 AS C1 FROM "SYS"."WRM$_BASELINE" "BL") innerQuery;

-- 分割线
SELECT COUNT(1) FROM DBA_HIST_BASELINE_METADATA AB ,BSLN_BASELINES B WHERE B.DBID = :B4 AND AB.DBID = B.DBID AND AB.BASELINE_ID = B.BASELINE_ID AND AB.BASELINE_TYPE = :B3 AND (B.LAST_COMPUTE_DATE IS NULL OR :B2 - B.LAST_COMPUTE_DATE >= :B1 );

-- 分割线
/* SQL Analyze(1) */ select /*+  full(t)    no_parallel(t) no_parallel_index(t) dbms_stats cursor_sharing_exact use_weak_name_resl dynamic_sampling(0) no_monitoring xmlindex_sel_idx_tbl opt_param('optimizer_inmemory_aware' 'false') no_substrb_pad  */to_char(count("BSLN_GUID")),substrb(dump(min("BSLN_GUID"),16,0,64),1,240),substrb(dump(max("BSLN_GUID"),16,0,64),1,240),to_char(count("METRIC_ID")),substrb(dump(min("METRIC_ID"),16,0,64),1,240),substrb(dump(max("METRIC_ID"),16,0,64),1,240),to_char(count("COMPUTE_DATE")),substrb(dump(min("COMPUTE_DATE"),16,0,64),1,240),substrb(dump(max("COMPUTE_DATE"),16,0,64),1,240),to_char(count("TIMEGROUPING")),substrb(dump(min("TIMEGROUPING"),16,0,64),1,240),substrb(dump(max("TIMEGROUPING"),16,0,64),1,240),to_char(count("TIMEGROUP")),substrb(dump(min("TIMEGROUP"),16,0,64),1,240),substrb(dump(max("TIMEGROUP"),16,0,64),1,240),to_char(count("SAMPLE_COUNT")),substrb(dump(min("SAMPLE_COUNT"),16,0,64),1,240),substrb(dump(max("SAMPLE_COUNT"),16,0,64),1,240),to_char(count("AVERAGE")),substrb(dump(min("AVERAGE"),16,0,64),1,240),substrb(dump(max("AVERAGE"),16,0,64),1,240),to_char(count("MINIMUM")),substrb(dump(min("MINIMUM"),16,0,64),1,240),substrb(dump(max("MINIMUM"),16,0,64),1,240),to_char(count("MAXIMUM")),substrb(dump(min("MAXIMUM"),16,0,64),1,240),substrb(dump(max("MAXIMUM"),16,0,64),1,240),to_char(count("SDEV")),substrb(dump(min("SDEV"),16,0,64),1,240),substrb(dump(max("SDEV"),16,0,64),1,240),to_char(count("PCTILE_25")),substrb(dump(min("PCTILE_25"),16,0,64),1,240),substrb(dump(max("PCTILE_25"),16,0,64),1,240),to_char(count("PCTILE_50")),substrb(dump(min("PCTILE_50"),16,0,64),1,240),substrb(dump(max("PCTILE_50"),16,0,64),1,240),to_char(count("PCTILE_75")),substrb(dump(min("PCTILE_75"),16,0,64),1,240),substrb(dump(max("PCTILE_75"),16,0,64),1,240),to_char(count("PCTILE_90")),substrb(dump(min("PCTILE_90"),16,0,64),1,240),substrb(dump(max("PCTILE_90"),16,0,64),1,240),to_char(count("PCTILE_95")),substrb(dump(min("PCTILE_95"),16,0,64),1,240),substrb(dump(max("PCTILE_95"),16,0,64),1,240),to_char(count("PCTILE_99")),substrb(dump(min("PCTILE_99"),16,0,64),1,240),substrb(dump(max("PCTILE_99"),16,0,64),1,240),to_char(count("EST_SAMPLE_COUNT")),substrb(dump(min("EST_SAMPLE_COUNT"),16,0,64),1,240),substrb(dump(max("EST_SAMPLE_COUNT"),16,0,64),1,240),to_char(count("EST_SLOPE")),substrb(dump(min("EST_SLOPE"),16,0,64),1,240),substrb(dump(max("EST_SLOPE"),16,0,64),1,240),to_char(count("EST_INTERCEPT")),substrb(dump(min("EST_INTERCEPT"),16,0,64),1,240),substrb(dump(max("EST_INTERCEPT"),16,0,64),1,240),to_char(count("EST_FIT_QUALITY")),substrb(dump(min("EST_FIT_QUALITY"),16,0,64),1,240),substrb(dump(max("EST_FIT_QUALITY"),16,0,64),1,240),to_char(count("EST_PCTILE_999")),substrb(dump(min("EST_PCTILE_999"),16,0,64),1,240),substrb(dump(max("EST_PCTILE_999"),16,0,64),1,240),to_char(count("EST_PCTILE_9999")),substrb(dump(min("EST_PCTILE_9999"),16,0,64),1,240),substrb(dump(max("EST_PCTILE_9999"),16,0,64),1,240),count(rowidtochar(rowid)) from "DBSNMP"."BSLN_STATISTICS" t  /* TOPN,NIL,NIL,TOPN,NIL,NIL,NDV,NIL,NIL,TOPN,NIL,NIL,TOPN,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,RWID,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254,U254U*/;

-- 分割线
SELECT BLDS.BSLN_GUID ,BLDS.METRIC_ID ,:B4 ,BLDS.TIMEGROUP ,BLDS.DBID ,BLDS.INSTANCE_NAME ,TP.THRESHOLD_METHOD ,TP.NUM_OCCURRENCES ,TP.WARNING_PARAM ,TP.CRITICAL_PARAM ,TP.FAIL_ACTION ,ST.SAMPLE_COUNT ,ROUND(ST.MINIMUM,3) AS MINIMUM ,ROUND(ST.MAXIMUM,3) AS MAXIMUM ,ROUND(ST.PCTILE_95,3) AS PCTILE_95 ,ROUND(ST.PCTILE_99,3) AS PCTILE_99 ,ROUND(ST.EST_PCTILE_999,3) AS PCTILE_999 ,ROUND(ST.EST_PCTILE_9999,3) AS PCTILE_9999 ,EST_FIT_QUALITY ,EST_SAMPLE_COUNT FROM BSLN_THRESHOLD_PARAMS TP ,BSLN_STATISTICS ST ,(SELECT B.BSLN_GUID AS BSLN_GUID ,B.DBID AS DBID ,B.INSTANCE_NAME AS INSTANCE_NAME ,B.TIMEGROUPING AS TIMEGROUPING ,BSLN.TIMEGROUP(B.TIMEGROUPING,:B4 ) AS TIMEGROUP ,D.METRIC_ID AS METRIC_ID FROM BSLN_BASELINES B ,BSLN_METRIC_DEFAULTS D WHERE B.STATUS = DECODE(:B2 , NULL, :B3 , B.STATUS) AND B.BSLN_GUID = NVL(:B2 ,B.BSLN_GUID) AND B.TIMEGROUPING IS NOT NULL AND D.METRIC_ID = NVL(:B1 ,D.METRIC_ID) ) BLDS WHERE BLDS.BSLN_GUID = TP.BSLN_GUID AND BLDS.METRIC_ID = TP.METRIC_ID AND BLDS.BSLN_GUID = ST.BSLN_GUID(+) AND BLDS.METRIC_ID = ST.METRIC_ID(+) AND BLDS.TIMEGROUP = ST.TIMEGROUP(+);

-- 分割线
SELECT value$ FROM LBACSYS.ols$props WHERE NAME = :1;

-- 分割线
/* SQL Analyze(386,1) */ SELECT NVL(:B4 , START_SNAP_ID) ,NVL(:B3 , END_SNAP_ID) FROM DBA_HIST_BASELINE WHERE DBID = :B2 AND BASELINE_ID = :B1 ;

-- 分割线
SELECT BSLN_VARIANCE_T( SS.METRIC_ID ,B.BSLN_GUID ,(CASE WHEN HOUR_OF_DAY IS NULL THEN (CASE WHEN DAY_NIGHT IS NULL THEN :B13 ELSE :B15 END) ELSE :B14 END)|| (CASE WHEN DAY_OF_WEEK IS NULL THEN (CASE WHEN WEEKDAY_WEEKEND IS NULL THEN :B13 ELSE :B12 END) ELSE :B11 END) ,(CASE WHEN HOUR_OF_DAY IS NULL THEN (CASE WHEN DAY_NIGHT IS NULL THEN 24 ELSE 12 END) ELSE 1 END)* (CASE WHEN DAY_OF_WEEK IS NULL THEN (CASE WEEKDAY_WEEKEND WHEN :B10 THEN 2 WHEN :B9 THEN 5 ELSE 7 END) ELSE 1 END) ,SUM(NUM_INTERVAL) ,CASE WHEN SUM(SS.NUM_INTERVAL) > 1 THEN (SUM(SS.SUM_SQUARES) - (SUM(SS.NUM_INTERVAL*SS.AVERAGE)*SUM(SS.NUM_INTERVAL*SS.AVERAGE))/SUM(SS.NUM_INTERVAL))/ (SUM(SS.NUM_INTERVAL)-1) ELSE 0 END ) FROM BSLN_BASELINES B ,DBA_HIST_BASELINE_METADATA AB ,DBA_HIST_SNAPSHOT SN ,DBA_HIST_DATABASE_INSTANCE DI ,DBA_HIST_SYSMETRIC_SUMMARY SS ,(SELECT HOUR AS HOUR_OF_WEEK ,TRUNC(HOUR/24) AS DAY_OF_WEEK ,MOD(HOUR,24) AS HOUR_OF_DAY ,INTRADAY AS DAY_NIGHT ,EXTRADAY AS WEEKDAY_WEEKEND FROM BSLN_TIMEGROUPS) TG WHERE B.DBID = :B8 AND B.AUTO_TIMEGROUP = :B7 AND AB.BASELINE_ID = B.BASELINE_ID AND AB.DBID = B.DBID AND AB.BASELINE_TYPE = :B6 AND SN.DBID = B.DBID AND SN.BEGIN_INTERVAL_TIME >= :B1 - LEAST(AB.MOVING_WINDOW_SIZE,:B2 ) AND DI.DBID = SN.DBID AND DI.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND DI.STARTUP_TIME = SN.STARTUP_TIME AND DI.INSTANCE_NAME = B.INSTANCE_NAME AND SS.SNAP_ID = SN.SNAP_ID AND SS.DBID = SN.DBID AND SS.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND SS.GROUP_ID = 2 AND SS.METRIC_ID IN (:B5 ,:B4 ,:B3 ) AND SS.BEGIN_TIME + (SS.END_TIME - SS.BEGIN_TIME)/2 BETWEEN :B1 - LEAST(AB.MOVING_WINDOW_SIZE,:B2 ) AND :B1 AND TG.HOUR_OF_WEEK = BSLN_INTERNAL.HOUR_OF_WEEK(SS.BEGIN_TIME + (SS.END_TIME - SS.BEGIN_TIME)/2) GROUP BY GROUPING SETS ((SS.METRIC_ID,B.BSLN_GUID,HOUR_OF_DAY,DAY_OF_WEEK), (SS.METRIC_ID,B.BSLN_GUID,HOUR_OF_DAY,WEEKDAY_WEEKEND), (SS.METRIC_ID,B.BSLN_GUID,HOUR_OF_DAY), (SS.METRIC_ID,B.BSLN_GUID,DAY_NIGHT,DAY_OF_WEEK), (SS.METRIC_ID,B.BSLN_GUID,DAY_NIGHT,WEEKDAY_WEEKEND), (SS.METRIC_ID,B.BSLN_GUID,DAY_NIGHT), (SS.METRIC_ID,B.BSLN_GUID,DAY_OF_WEEK), (SS.METRIC_ID,B.BSLN_GUID,WEEKDAY_WEEKEND), (SS.METRIC_ID,B.BSLN_GUID));

-- 分割线
SELECT INSTANCE_NAME FROM SYS.V_$INSTANCE;

-- 分割线
SELECT EXTRACT(DAY FROM SNAP_INTERVAL)*1440 +EXTRACT(HOUR FROM SNAP_INTERVAL)*60 +EXTRACT(MINUTE FROM SNAP_INTERVAL) FROM DBA_HIST_WR_CONTROL WHERE DBID = NVL(:B1 , BSLN_INTERNAL.THIS_DBID);

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "WRM$_SNAPSHOT#3")  */ 1 AS C1 FROM "SYS"."WRM$_SNAPSHOT" "WRM$_SNAPSHOT#3", "BSLN_METRIC_DEFAULTS" "MD#0", "SYS"."WRM$_DATABASE_INSTANCE" "WRM$_DATABASE_INSTANCE#2" WHERE ("WRM$_DATABASE_INSTANCE#2"."INSTANCE_NAME"=:B1) AND ("WRM$_DATABASE_INSTANCE#2"."DBID"=:B2) AND ("MD#0"."STATUS"=:B3) AND ("WRM$_SNAPSHOT#3"."DBID"=:B4) AND ("WRM$_DATABASE_INSTANCE#2"."DBID"="WRM$_SNAPSHOT#3"."DBID") AND ("WRM$_DATABASE_INSTANCE#2"."INSTANCE_NUMBER"="WRM$_SNAPSHOT#3"."INSTANCE_NUMBER") AND ("WRM$_DATABASE_INSTANCE#2"."STARTUP_TIME"="WRM$_SNAPSHOT#3"."STARTUP_TIME") AND ("WRM$_SNAPSHOT#3"."STATUS"=0) AND ("WRM$_SNAPSHOT#3"."SNAP_ID">=:B5) AND ("WRM$_SNAPSHOT#3"."SNAP_ID"<=:B6)) innerQuery;

-- 分割线
SELECT NVL(:B4 , START_SNAP_ID) ,NVL(:B3 , END_SNAP_ID) FROM DBA_HIST_BASELINE WHERE DBID = :B2 AND BASELINE_ID = :B1 ;

-- 分割线
WITH TIMEGROUPED_RAWDATA AS (SELECT /*+ LEADING(SN DI MD SH OT) CARDINALITY(OT 1000) */ SH.METRIC_ID AS METRIC_ID ,OT.BSLN_GUID AS BSLN_GUID ,OT.TIMEGROUP AS TIMEGROUP ,SH.VALUE AS OBS_VALUE FROM DBA_HIST_SNAPSHOT SN ,DBA_HIST_DATABASE_INSTANCE DI ,SYS.WRH$_SYSMETRIC_HISTORY SH ,BSLN_METRIC_DEFAULTS MD ,TABLE(:B1 ) OT WHERE SN.DBID = :B6 AND SN.SNAP_ID BETWEEN :B5 AND :B4 AND DI.DBID = SN.DBID AND DI.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND DI.STARTUP_TIME = SN.STARTUP_TIME AND DI.INSTANCE_NAME = :B3 AND SH.SNAP_ID = SN.SNAP_ID AND SH.DBID = SN.DBID AND SH.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND SH.GROUP_ID = 2 AND SH.METRIC_ID = MD.METRIC_ID AND MD.STATUS = :B2 AND OT.OBS_TIME = TRUNC(SH.END_TIME, 'HH24') ) (SELECT BSLN_STATISTICS_T (BSLN_GUID ,METRIC_ID ,:B11 ,:B10 ,TIMEGROUP ,SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 ,EST_SAMPLE_COUNT ,EST_SLOPE ,EST_INTERCEPT ,CASE WHEN EST_SLOPE = 0 THEN 0 ELSE GREATEST(0,NVL(100-(25*POWER((1-EST_MU1/EST_SLOPE), 2)*(EST_SAMPLE_COUNT-1) ),0)) END ,LN( 1000) * EST_SLOPE + EST_INTERCEPT ,LN(10000) * EST_SLOPE + EST_INTERCEPT ) FROM (SELECT METRIC_ID ,BSLN_GUID ,TIMEGROUP ,EST_MU AS EST_SLOPE ,EST_MU * LN(ALPHA) + X_M AS EST_INTERCEPT ,TO_NUMBER(NULL) AS EST_FIT_QUALITY ,CASE WHEN COUNT_BELOW_X_J > 0 THEN (SUM_BELOW_X_J + (N-M+1)*(X_J-X_M))/COUNT_BELOW_X_J - X_J ELSE TO_NUMBER(NULL) END AS EST_MU1 ,EST_SAMPLE_COUNT ,N AS SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 FROM (SELECT METRIC_ID ,BSLN_GUID ,TIMEGROUP ,MAX(N) AS N ,COUNT(RRANK) AS EST_SAMPLE_COUNT ,CASE WHEN COUNT(RRANK) > 3 THEN ( SUM(OBS_VALUE) + ( MAX(N) - MAX(RRANK) ) * MAX(OBS_VALUE) - (MAX(N) - MIN(RRANK) + 1) * MIN(OBS_VALUE) ) / (COUNT(RRANK)-1) ELSE TO_NUMBER(NULL) END AS EST_MU ,(MAX(N) - MIN(RRANK) + 1) / (MAX(N) + 1) AS ALPHA ,MIN(OBS_VALUE) AS X_M ,MAX(OBS_VALUE) AS X_L ,MAX(RRANK) AS L ,MIN(RRANK) AS M ,MAX(MID_TAIL_VALUE) AS X_J ,SUM(CASE WHEN OBS_VALUE < MID_TAIL_VALUE THEN OBS_VALUE ELSE 0 END ) AS SUM_BELOW_X_J ,SUM(CASE WHEN CUME_DIST < :B7 THEN 1 ELSE 0 END ) AS COUNT_BELOW_X_J ,MAX(MAX_VAL) AS MAXIMUM ,MAX(MIN_VAL) AS MINIMUM ,MAX(AVG_VAL) AS AVERAGE ,MAX(SDEV_VAL) AS SDEV ,MAX(PCTILE_25) AS PCTILE_25 ,MAX(PCTILE_50) AS PCTILE_50 ,MAX(PCTILE_75) AS PCTILE_75 ,MAX(PCTILE_90) AS PCTILE_90 ,MAX(PCTILE_95) AS PCTILE_95 ,MAX(PCTILE_99) AS PCTILE_99 FROM (SELECT METRIC_ID ,BSLN_GUID ,TIMEGROUP ,OBS_VALUE AS OBS_VALUE ,CUME_DIST () OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ORDER BY OBS_VALUE ) AS CUME_DIST ,COUNT(1) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ) AS N ,ROW_NUMBER () OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ORDER BY OBS_VALUE) AS RRANK ,PERCENTILE_DISC(:B7 ) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS MID_TAIL_VALUE ,MAX(OBS_VALUE) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ) AS MAX_VAL ,MIN(OBS_VALUE) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ) AS MIN_VAL ,AVG(OBS_VALUE) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ) AS AVG_VAL ,STDDEV(OBS_VALUE) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP ) AS SDEV_VAL ,PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_25 ,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_50 ,PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_75 ,PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_90 ,PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_95 ,PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID, BSLN_GUID, TIMEGROUP) AS PCTILE_99 FROM TIMEGROUPED_RAWDATA D ) X WHERE X.CUME_DIST >= :B9 AND X.CUME_DIST <= :B8 GROUP BY METRIC_ID ,BSLN_GUID ,TIMEGROUP ) ) );

-- 分割线
DELETE FROM BSLN_STATISTICS WHERE BSLN_GUID = :B2 AND TIMEGROUPING = :B1 ;

-- 分割线
UPDATE BSLN_BASELINES SET TIMEGROUPING = BSLN_INTERNAL.ELECTED_TIMEGROUPING(:B1 ,:B3 ,:B2 ) WHERE BSLN_GUID = :B1 ;

-- 分割线
SELECT BASELINE_ID ID ,DBID ,INSTANCE_NAME ,BSLN_GUID GUID ,TIMEGROUPING FROM BSLN_BASELINES WHERE BASELINE_ID = :B4 AND DBID = :B3 AND (LAST_COMPUTE_DATE IS NULL OR :B2 - LAST_COMPUTE_DATE >= :B1 );

-- 分割线
SELECT C.METRIC_ID ,C.HOUR_FIELD CANDIDATE_HOUR ,C.DAY_FIELD CANDIDATE_DAY ,SUM(C.TIMEGROUP_HOURS*C.TIMEGROUP_VARIANCE) WEIGHTED_VAR FROM (SELECT X.METRIC_ID ,SUBSTR(X.TIMEGROUPING,1,1) HOUR_FIELD ,SUBSTR(X.TIMEGROUPING,2,1) DAY_FIELD ,X.TIMEGROUP_HOURS ,X.TIMEGROUP_CARDINALITY ,X.TIMEGROUP_VARIANCE FROM TABLE(CAST(:B1 AS BSLN_VARIANCE_SET)) X WHERE X.BSLN_GUID = :B2 ) C GROUP BY C.METRIC_ID, C.HOUR_FIELD, C.DAY_FIELD HAVING SUM(C.TIMEGROUP_HOURS) = 168 AND MIN(C.TIMEGROUP_CARDINALITY) > 200 ORDER BY 4 DESC;

-- 分割线
SELECT COUNT(*) FROM SYS.V_$PARAMETER2 WHERE NAME='_gwm_database_flags';

-- 分割线
SELECT DBID FROM SYS.V_$DATABASE;

-- 分割线
/* SQL Analyze(130,1) */ WITH NONTIMEGROUPED_RAWDATA AS (SELECT MD.METRIC_ID ,SH.END_TIME AS OBS_TIME ,SH.VALUE AS OBS_VALUE FROM DBA_HIST_SNAPSHOT SN ,DBA_HIST_DATABASE_INSTANCE DI ,SYS.WRH$_SYSMETRIC_HISTORY SH ,BSLN_METRIC_DEFAULTS MD WHERE SN.DBID = :B5 AND SN.SNAP_ID BETWEEN :B4 AND :B3 AND DI.DBID = SN.DBID AND DI.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND DI.STARTUP_TIME = SN.STARTUP_TIME AND DI.INSTANCE_NAME = :B2 AND SH.SNAP_ID = SN.SNAP_ID AND SH.DBID = SN.DBID AND SH.INSTANCE_NUMBER = SN.INSTANCE_NUMBER AND SH.GROUP_ID = 2 AND SH.METRIC_ID = MD.METRIC_ID AND MD.STATUS = :B1 ) SELECT BSLN_STATISTICS_T (:B12 ,METRIC_ID ,:B11 ,:B10 ,:B9 ||':'||:B9 ,SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 ,EST_SAMPLE_COUNT ,EST_SLOPE ,EST_INTERCEPT ,CASE WHEN EST_SLOPE = 0 THEN 0 ELSE GREATEST(0,NVL(100-(25*POWER((1-EST_MU1/EST_SLOPE), 2)*(EST_SAMPLE_COUNT-1) ),0)) END ,LN( 1000) * EST_SLOPE + EST_INTERCEPT ,LN(10000) * EST_SLOPE + EST_INTERCEPT ) FROM (SELECT METRIC_ID ,EST_MU AS EST_SLOPE ,EST_MU * LN(ALPHA) + X_M AS EST_INTERCEPT ,TO_NUMBER(NULL) AS EST_FIT_QUALITY ,CASE WHEN COUNT_BELOW_X_J > 0 THEN (SUM_BELOW_X_J + (N-M+1)*(X_J-X_M))/COUNT_BELOW_X_J - X_J ELSE TO_NUMBER(NULL) END AS EST_MU1 ,EST_SAMPLE_COUNT ,N AS SAMPLE_COUNT ,AVERAGE ,MINIMUM ,MAXIMUM ,SDEV ,PCTILE_25 ,PCTILE_50 ,PCTILE_75 ,PCTILE_90 ,PCTILE_95 ,PCTILE_99 FROM (SELECT METRIC_ID ,MAX(N) AS N ,COUNT(RRANK) AS EST_SAMPLE_COUNT ,CASE WHEN COUNT(RRANK) > 3 THEN ( SUM(OBS_VALUE) + ( MAX(N) - MAX(RRANK) ) * MAX(OBS_VALUE) - (MAX(N) - MIN(RRANK) + 1) * MIN(OBS_VALUE) ) / (COUNT(RRANK)-1) ELSE TO_NUMBER(NULL) END AS EST_MU ,(MAX(N) - MIN(RRANK) + 1) / (MAX(N) + 1) AS ALPHA ,MIN(OBS_VALUE) AS X_M ,MAX(OBS_VALUE) AS X_L ,MAX(RRANK) AS L ,MIN(RRANK) AS M ,MAX(MID_TAIL_VALUE) AS X_J ,SUM(CASE WHEN OBS_VALUE < MID_TAIL_VALUE THEN OBS_VALUE ELSE 0 END ) AS SUM_BELOW_X_J ,SUM(CASE WHEN CUME_DIST < :B6 THEN 1 ELSE 0 END ) AS COUNT_BELOW_X_J ,MAX(MAX_VAL) AS MAXIMUM ,MAX(MIN_VAL) AS MINIMUM ,MAX(AVG_VAL) AS AVERAGE ,MAX(SDEV_VAL) AS SDEV ,MAX(PCTILE_25) AS PCTILE_25 ,MAX(PCTILE_50) AS PCTILE_50 ,MAX(PCTILE_75) AS PCTILE_75 ,MAX(PCTILE_90) AS PCTILE_90 ,MAX(PCTILE_95) AS PCTILE_95 ,MAX(PCTILE_99) AS PCTILE_99 FROM (SELECT METRIC_ID ,OBS_VALUE AS OBS_VALUE ,CUME_DIST () OVER (PARTITION BY METRIC_ID ORDER BY OBS_VALUE ) AS CUME_DIST ,COUNT(1) OVER (PARTITION BY METRIC_ID ) AS N ,ROW_NUMBER () OVER (PARTITION BY METRIC_ID ORDER BY OBS_VALUE) AS RRANK ,PERCENTILE_DISC(:B6 ) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS MID_TAIL_VALUE ,MAX(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS MAX_VAL ,MIN(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS MIN_VAL ,AVG(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS AVG_VAL ,STDDEV(OBS_VALUE) OVER (PARTITION BY METRIC_ID ) AS SDEV_VAL ,PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_25 ,PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_50 ,PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_75 ,PERCENTILE_CONT(0.90) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_90 ,PERCENTILE_CONT(0.95) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_95 ,PERCENTILE_CONT(0.99) WITHIN GROUP (ORDER BY OBS_VALUE ASC) OVER (PARTITION BY METRIC_ID) AS PCTILE_99 FROM NONTIMEGROUPED_RAWDATA D ) X WHERE X.CUME_DIST >= :B8 AND X.CUME_DIST <= :B7 GROUP BY METRIC_ID ));

-- 分割线
INSERT INTO BSLN_STATISTICS SELECT XX.* FROM TABLE(:B1 ) XX;

-- 分割线
SELECT * FROM BSLN_BASELINES WHERE BSLN_GUID = :B1 ;

-- 分割线
SELECT /* DS_SVC */ /*+ dynamic_sampling(0) no_sql_tune no_monitoring optimizer_features_enable(default) no_parallel  */ NVL(SUM(C1),0) FROM (SELECT /*+ qb_name("innerQuery") NO_INDEX_FFS( "MD")  */ 1 AS C1 FROM "BSLN_METRIC_DEFAULTS" "MD" WHERE ("MD"."STATUS"=:B1)) innerQuery;

-- 分割线
explain plan set statement_id='1642056088598' for select * from table(dbms_xplan.display_cursor('fsw8111ja9wbd'));

-- 分割线
explain plan set statement_id='1640934694479' for select * from table(dbms_xplan.display_cursor('1y6ps9bvsj76t'));

-- 分割线
explain plan set statement_id='1641285061256' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '34tjrj99rfapp' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1645777891532' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='4bggnvq4b8cy3'and is_obsolete = 'N' and child_number =0;

-- 分割线
explain plan set statement_id='1641889873701' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST1';

-- 分割线
select  * from table(dbms_xplan.display_cursor('6b49jkmx46rmv'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('b1bsr647rtxsk'));

-- 分割线
explain plan set statement_id='1641544234127' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST_1';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ rtrim(sql_text) 
                         from v$sql where SQL_ID=:v_sql_id 
                                    and child_number=:v_child_number
                                    and is_obsolete = 'N';

-- 分割线
SELECT  TIMESTAMP,ID,LPAD('  ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_ID FROM PLAN_TABLE WHERE STATEMENT_ID = :1  ORDER BY TIMESTAMP,id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('3vsmzjzyt35ky'));

-- 分割线
explain plan set statement_id='1646702432542' for SELECT ET.TABLE_NAME EXT_TABLE_NAME, T.TABLE_NAME, T.IOT_TYPE FROM SYS.ALL_ALL_TABLES T, SYS.ALL_EXTERNAL_TABLES ET, SYS.ALL_TAB_COMMENTS TC WHERE T.IOT_NAME IS NULL AND T.NESTED = 'NO' AND T.SECONDARY = 'N' AND NOT EXISTS (SELECT 1 FROM SYS.ALL_MVIEWS MV WHERE MV.OWNER = T.OWNER AND MV.MVIEW_NAME = T.TABLE_NAME) AND TC.OWNER(+) = T.OWNER AND TC.TABLE_NAME(+) = T.TABLE_NAME AND ET.TABLE_NAME(+) = T.TABLE_NAME AND ET.OWNER(+) = T.OWNER AND T.OWNER = 'TEST' ORDER BY T.TABLE_NAME ASC;

-- 分割线
explain plan set statement_id='1641453074891' for select * from table(dbms_xplan.display_cursor('g1j4gnu80vf6h'));

-- 分割线
explain plan set statement_id='1641371382892' for select * from table(dbms_xplan.display_cursor('bvuf3a6p7zrm9'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'PLAN_TABLE' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1642062667065' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'bx7tcw6zm75b3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646731691779' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_EXTERNAL_TABLES' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('gq43zfkvh3m7j'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'g0ws1f49b0a27' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641544228127' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1640140554532' for with T1 as(select * from TEST.TABLE_EXPLAIN1) select * from T1;

-- 分割线
explain plan set statement_id='1641453079752' for select * from table(dbms_xplan.display_cursor('avh86urnpa9hx'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('2fauhvjuwj4k8'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1645777889008' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'dtbp8qkxufjgk' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('bv7kbhp83f6tn'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5v5agnypjkc24'));

-- 分割线
explain plan set statement_id='1646637414511' for SELECT u.NAME FROM sys.USER$ u WHERE u.TYPE# = 1 ORDER BY 1;

-- 分割线
select  * from table(dbms_xplan.display_cursor('9wdyv0zfmm9u8'));

-- 分割线
explain plan set statement_id='1641285062060' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='6dhqk6msdmgq7'and is_obsolete = 'N' and child_number =0;

-- 分割线
begin if dbms_utility.is_cluster_database then :isRAC := 1; else :isRAC := 0; end if; end;;

-- 分割线
explain plan set statement_id='1648457229748' for select line||':'||position||':'||text as message from sys.all_errors where type = 'TABLE' and owner = :1 and name = :2 order by sequence;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1648537935369' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1648543646316' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('drg9xx32s8d8x'));

-- 分割线
explain plan set statement_id='1641453075142' for select * from table(dbms_xplan.display_cursor('6p1un7ryqtgr6'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641971528121' for select * from table(dbms_xplan.display_cursor('2pyxt8v955cpr'));

-- 分割线
explain plan set statement_id='1642056085996' for select * from table(dbms_xplan.display_cursor('46utf6h6vmrzj'));

-- 分割线
SELECT * FROM V$ARCHIVE_DEST
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('0ushr863b7z39'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'fs4ym5u7p555f' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('bu9qfbj2uz5sk'));

-- 分割线
SELECT * FROM NLS_SESSION_PARAMETERS;

-- 分割线
explain plan set statement_id='1640140550476' for SELECT COUNT(*) FROM TEST.TABLE_EXPLAIN1 WHERE C1=3;

-- 分割线
Select owner, object_name, object_type
from sys.DBA_OBJECTS
where object_name = :obj
and object_type not like '%PARTITION%'
union all
Select owner, constraint_name as object_name, 'CONSTRAINT' as object_type
from sys.DBA_CONSTRAINTS
where constraint_name = :obj
order by 3;

-- 分割线
explain plan set statement_id='1640934724967' for select * from table(dbms_xplan.display_cursor('at9qcygw7g05p'));

-- 分割线
explain plan set statement_id='1628737278157' for SELECT ET.TABLE_NAME EXT_TABLE_NAME, T.TABLE_NAME, T.IOT_TYPE FROM SYS.ALL_ALL_TABLES T, SYS.ALL_EXTERNAL_TABLES ET, SYS.ALL_TAB_COMMENTS TC WHERE T.IOT_NAME IS NULL AND T.NESTED = 'NO' AND T.SECONDARY = 'N' AND NOT EXISTS (SELECT 1 FROM SYS.ALL_MVIEWS MV WHERE MV.OWNER = T.OWNER AND MV.MVIEW_NAME = T.TABLE_NAME) AND TC.OWNER(+) = T.OWNER AND TC.TABLE_NAME(+) = T.TABLE_NAME AND ET.TABLE_NAME(+) = T.TABLE_NAME AND ET.OWNER(+) = T.OWNER AND T.OWNER = 'TEST' ORDER BY T.TABLE_NAME ASC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1648517492545' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1642056086677' for select * from table(dbms_xplan.display_cursor('bvhghpg1ykmgq'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641453079040' for select * from table(dbms_xplan.display_cursor('f86ng805zdqt8'));

-- 分割线
explain plan set statement_id='1640856674019' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'NLS_SESSION_PARAMETERS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640766679140' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count,creator from v$archived_log where completion_time > sysdate - 2 order by 2,3,4;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST' AND OWNER='ADMIN';

-- 分割线
SELECT /* OPT_DYN_SAMP */ /*+ ALL_ROWS IGNORE_WHERE_CLAUSE NO_PARALLEL(SAMPLESUB) opt_param('parallel_execution_enabled', 'false') NO_PARALLEL_INDEX(SAMPLESUB) NO_SQL_TUNE */ NVL(SUM(C1),0), NVL(SUM(C2),0) FROM (SELECT /*+ IGNORE_WHERE_CLAUSE NO_PARALLEL("PLAN_TABLE") FULL("PLAN_TABLE") NO_PARALLEL_INDEX("PLAN_TABLE") */ 1 AS C1, CASE WHEN "PLAN_TABLE"."STATEMENT_ID"=:B1 THEN 1 ELSE 0 END AS C2 FROM "SYS"."PLAN_TABLE$" "PLAN_TABLE") SAMPLESUB;

-- 分割线
Declare
  debug_connect_session number;
  alter_session number;
  alter_system number;
  alter_database number;
  select_any_table number;
  grant_any_object_priv number;
  select_any_dictionary number;
  update_any_table number;
  create_public_syn number;
  has_dba_synonyms number;
  has_dba_objects number;
  select_catalog_role number;
  db_charset nls_database_parameters.value%type;
  compatible_version varchar2(60);
  sid number;
  local_trans_id varchar2(60);
  qry_str varchar2(4000);
  has_dbms_java number;
  has_dbms_debug number;
  qu_version_owner varchar2(30);
  CTRepositoryVersion number;
  is_RAC number;
  instance_id number;
  instance_name varchar2(100);
  server_name varchar2(100);
  team_coding_schema varchar2(30);
  team_coding_table varchar2(30);
  team_coding_synonym varchar2(30);
  team_coding_table_selectable number;
  has_nav_tc number;
  authentication_type varchar2(30);
  AmazonRDSPackage varchar2(30);
  cx_table_count number;
Begin
  -- Put Toad data into v$session columns
  SYS.DBMS_APPLICATION_INFO.SET_MODULE(:IN_MDL, null);
  -- 
  -- 
  -- Retrieve specific system privileges
  select
    sum(decode(Privilege, 'DEBUG CONNECT SESSION', 1, 0)) debug_connect_session,
    sum(decode(Privilege, 'ALTER SESSION', 1, 0)) alter_session,
    sum(decode(Privilege, 'ALTER SYSTEM', 1, 0)) alter_system,
    sum(decode(Privilege, 'ALTER DATABASE', 1, 0)) alter_database,
    sum(decode(Privilege, 'SELECT ANY TABLE', 1, 0)) select_any_table,
    sum(decode(Privilege, 'UPDATE ANY TABLE', 1, 0)) update_any_table,
    sum(decode(Privilege, 'GRANT ANY OBJECT PRIVILEGE', 1, 0)) grant_any_object_priv,
    sum(decode(Privilege, 'SELECT ANY DICTIONARY', 1, 0)) select_any_dictionary,
    sum(decode(Privilege, 'CREATE PUBLIC SYNONYM', 1, 0)) create_public_syn
  into debug_connect_session, alter_session, alter_system, alter_database, select_any_table, update_any_table, grant_any_object_priv, select_any_dictionary, create_public_syn
  from sys.session_privs
  where privilege in ('DEBUG CONNECT SESSION',
                      'ALTER SESSION',
                      'ALTER SYSTEM',
                      'ALTER DATABASE',
                      'SELECT ANY TABLE',
                      'UPDATE ANY TABLE',
                      'GRANT ANY OBJECT PRIVILEGE',
                      'SELECT ANY DICTIONARY',
                      'CREATE PUBLIC SYNONYM');
  -- 
  -- Check for SELECT_CATALOG_ROLE.  It must be a default role to appear in the result of this query.
  Select
    sum(decode(role, 'SELECT_CATALOG_ROLE', 1, 0)) select_catalog_role
  into select_catalog_role
  from sys.session_roles
  where role = 'SELECT_CATALOG_ROLE';
  -- 
  -- determine database character set
  select value into db_charset from sys.nls_database_parameters where parameter = 'NLS_CHARACTERSET';
  -- 
  -- check for other ways dba_objects and dba_synonyms could be granted
 if (select_any_dictionary = 1) or (select_catalog_role = 1) then
   has_dba_synonyms := 1;
   has_dba_objects := 1;
 else
    begin
      select sum(decode(table_name, 'DBA_SYNONYMS', 1, 0)) dba_syns,
             sum(decode(table_name, 'DBA_OBJECTS', 1, 0)) dba_objs
      into   has_dba_synonyms, has_dba_objects
      from   sys.table_privileges
      where  owner = 'SYS'
      and    table_name in ('DBA_SYNONYMS', 'DBA_OBJECTS')
      and    select_priv in ('Y', 'G');
    exception
    when no_data_found then
      has_dba_synonyms := 0;
      has_dba_objects := 0;
    end;
  end if;
  -- 
  -- retrieve SID if possible
  begin
    qry_str := 'select SYS_CONTEXT(''USERENV'',''SID'') from dual';
    execute immediate qry_str into sid;
  exception
    when others then
      sid := -1;
  end;
  --
  -- get authentication type
  begin
    qry_str := 'Select SYS_CONTEXT(''USERENV'', ''IDENTIFICATION_TYPE'') from dual';
    execute immediate qry_str into authentication_type;
  exception
    when others then
      authentication_type := null;
  end;
  --
  -- get compatible version
    begin
      qry_str := 'select value from v$parameter where name = ''compatible''';
      execute immediate qry_str into compatible_version;
    exception
      when others then
        compatible_version := null;
    end;
  -- 
  -- check for privileges on sys.dbms_transaction
  begin
    execute immediate 'select sys.dbms_transaction.local_transaction_id from dual' into local_trans_id;
  exception
    when others then
      local_trans_id := '<error>';
  end;
  -- 
  -- determine if certain packages are installed
  qry_str := 'Select sum(decode(object_name, ''DBMS_JAVA'', 1, 0)) jv,' ||
             '       sum(decode(object_name, ''DBMS_DEBUG'', 1, 0)) dbg ';
  if has_dba_objects > 0 then
    qry_str := qry_str || 'from sys.dba_objects ';
  else  
    qry_str := qry_str || 'from sys.all_objects ';
  end if;
  qry_str := qry_str || 'where owner = ''SYS'' ' ||
             'and object_type = ''PACKAGE'' ' ||
             'and object_name in (''DBMS_JAVA'', ''DBMS_DEBUG'')';
  execute immediate qry_str into has_dbms_java, has_dbms_debug;
  -- 
  -- determine if code tester repository is installed
  begin
    Select user into qu_version_owner
    FROM   sys.user_objects
    WHERE  object_name = 'QU_VERSION'
    AND    object_type in ('PACKAGE', 'SYNONYM')
    AND    rownum = 1;
  exception
    when no_data_found then
      qu_version_owner := null;
  end;
  -- if not found then look in other schemas
  if qu_version_owner is null then
    begin
      qry_str := 'Select owner ';
      if has_dba_objects > 0 then
        qry_str := qry_str || 'from sys.dba_objects ';
      else
        qry_str := qry_str || 'from sys.all_objects ';
      end if;
      qry_str := qry_str || 'where object_name = ''QU_VERSION'' ' ||
             'and object_type in (''PACKAGE'',''SYNONYM'') and rownum = 1';
      execute immediate qry_str into qu_version_owner;
    exception
      when others then
        qu_version_owner := null;
    end;
  end if;
  -- 
  -- if it is installed, determine code tester version
  CTRepositoryVersion := 0;
  if qu_version_owner is not null then
    begin
      qry_str := 'select (10 * QU_VERSION.major_number) + QU_VERSION.minor_number from dual';
      execute immediate qry_str into CTRepositoryVersion;
    exception
      when others then
        CTRepositoryVersion := 0;
    end;
  end if;
  -- 
  -- find the team coding schema, if any
  begin
    -- all_objects is generally faster than all_synonyms, so first look there to see if the synonym exists.
    qry_str := 'Select object_name ';
    if has_dba_objects > 0 then
      qry_str := qry_str || 'from sys.dba_objects ';
    else
      qry_str := qry_str || 'from sys.all_objects ';
    end if;
    qry_str := qry_str || 'where owner = ''PUBLIC'' and object_name = ''QUEST_COM_TEAM_CODING'' and object_type = ''SYNONYM'' ';
    execute immediate qry_str into team_coding_synonym;
  exception
    when others then
      team_coding_synonym := null;
  end;
  -- now look to find team coding table name only if we know synonym exists.
  if team_coding_synonym is not null then
    begin
      qry_str := 'Select table_owner, table_name ';
      if has_dba_synonyms > 0 then
        qry_str := qry_str || 'from sys.dba_synonyms ';
      else
        qry_str := qry_str || 'from sys.all_synonyms ';
      end if;
      qry_str := qry_str || 'where synonym_name = ''QUEST_COM_TEAM_CODING'' and owner = ''PUBLIC'' ';
      execute immediate qry_str into team_coding_schema, team_coding_table;
    exception
      when others then
        team_coding_schema := null;
        team_coding_table := null;
    end;
  end if;
  -- if we found a table, make sure we can select from it.
  if team_coding_table is not null then
    begin
      qry_str := 'SELECT 1 FROM ' || team_coding_schema || '.' || team_coding_table || ' where rownum = 1';
      execute immediate qry_str into team_coding_table_selectable;
    exception
      when no_data_found then
        team_coding_table_selectable := 1;
      when others then
        team_coding_table_selectable := 0;
    end;
  else
    -- 
    -- if not, see if sql nav team coding table exists
    team_coding_table_selectable := 0;
    qry_str := 'Select 1 ';
    if has_dba_objects > 0 then
      qry_str := qry_str || 'from sys.dba_objects ';
    else  
      qry_str := qry_str || 'from sys.all_objects ';
    end if;
    qry_str := qry_str || 'where object_type = ''TABLE'' ' ||
               'and object_name = ''SQLNAV_PROGRAM_STATUS_LOG''';
    begin
      execute immediate qry_str into has_nav_tc;
    exception
      when no_data_found then
        has_nav_tc := 0;
    end;
  end if;
  -- 
  -- determine if this is a RAC instance
  qry_str := 'begin if dbms_utility.is_cluster_database';
  qry_str := qry_str || ' then :isRAC := 1; else :isRAC := 0; end if; end;';
  -- 
  -- determine if this is a RAC DB
  begin
    execute immediate qry_str using out is_RAC;
  exception
    when others then
      :isRAC := 0;
  end;
  -- 
  -- determine instance id
  begin
    execute immediate 'select dbms_utility.current_instance from dual' into instance_id;
  exception
    when others then
      instance_id := 1;
  end;
  -- 
  -- determine instance name and server name if possible
  qry_str := 'select sys_context(''USERENV'',''INSTANCE_NAME''), sys_context(''USERENV'',''SERVER_HOST'') from dual';
  begin
    execute immediate qry_str into instance_name, server_name;
  exception
    -- if we don't have privs on v$instance and not rac, then try to get db name
    when others then
      if is_rac = 0 then
        begin
          qry_str := 'select sys_context(''USERENV'',''DB_NAME'') from dual';
          execute immediate qry_str into instance_name;
        exception
          when others then
             instance_name := null;
        end;
      end if;
  end;
  -- 
  -- Is this an Amazon RDS Instance?
  begin
    execute immediate 'select object_name from sys.all_procedures where owner = ''RDSADMIN'' and object_name = ''RDSADMIN_UTIL'' and object_type = ''PACKAGE'' and subprogram_id = 0'  into AmazonRDSPackage;
  exception
    when others then
      AmazonRDSPackage := null;
  end;
  -- 
  -- check for existence of Codexpert tables
  Select count('x')
  into cx_table_count
  from sys.all_tables
  where owner in ('TOAD', USER)
  and table_name in ('CX_XPERTRUN', 'CX_XPERTLINES', 'CX_XPERTITEMS', 'CX_TYPES', 'CX_SEVERITYS', 'CX_SETRULES', 'CX_RULESETS', 'CX_METRICS', 'CX_METRICRANGES', 'CX_CATEGORYS', 'CX_BASERULES');
  -- 
  -- Assign results to output variables
  :OUT_DEBUG_CONNECT_SESSION := debug_connect_session;
  :OUT_ALTER_SESSION := alter_session;
  :OUT_ALTER_SYSTEM := alter_system;
  :OUT_ALTER_DATABASE := alter_database;
  :OUT_SELECT_ANY_TABLE := select_any_table;
  :OUT_UPDATE_ANY_TABLE := update_any_table;
  :OUT_GRANT_ANY_OBJECT_PRIV := grant_any_object_priv;
  :OUT_SELECT_ANY_DICTIONARY := select_any_dictionary;
  :OUT_CREATE_PUBLIC_SYN := create_public_syn;
  :OUT_SELECT_CATALOG_ROLE := select_catalog_role;
  :OUT_USER := user;
  :OUT_DB_CHARSET := db_charset;
  :OUT_CX_TABLE_COUNT := cx_table_count;
  :OUT_COMPATIBLE_VERSION := compatible_version;
  :OUT_TEAM_CODING_SCHEMA := team_coding_schema;
  :OUT_TEAM_CODING_TABLE := team_coding_table;
  :OUT_TC_TABLE_SELECTABLE := team_coding_table_selectable;
  :OUT_HAS_NAV_TC := has_nav_tc;
  :OUT_SID := sid;
  :OUT_LOCAL_TRANS_ID := local_trans_id;
  :OUT_HAS_DBMS_JAVA := has_dbms_java;
  :OUT_HAS_DBMS_DEBUG := has_dbms_debug;
  :OUT_QU_VERSION_OWNER := qu_version_owner;
  :OUT_QU_VERSION := CTRepositoryVersion;
  :OUT_IS_RAC := is_rac;
  :OUT_INSTANCE_ID := instance_id;
  :OUT_INSTANCE_NAME := instance_name;
  :OUT_SERVER_NAME := server_name;
  :OUT_AUTHENTICATION_TYPE := authentication_type;
  :OUT_IS_AMAZON_RDS := AmazonRDSPackage;
end;;

-- 分割线
explain plan set statement_id='1641453079806' for select * from table(dbms_xplan.display_cursor('0bsxvrxsa5wqy'));

-- 分割线
select null from dual
;

-- 分割线
/*NDTM*/SELECT TABLESPACE_NAME AS TBSPNAME,STATUS FROM DBA_TABLESPACES;

-- 分割线
explain plan set statement_id='1645691396258' for select * from TEST_TFY;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='SYS';

-- 分割线
/* SQL Analyze(0) */ select /*+  full(t)    no_parallel(t) no_parallel_index(t) dbms_stats cursor_sharing_exact use_weak_name_resl dynamic_sampling(0) no_monitoring no_substrb_pad  */to_char(count("VALID")),to_char(substrb(dump(min("VALID"),16,0,32),1,120)),to_char(substrb(dump(max("VALID"),16,0,32),1,120)),to_char(count("ISALIVE")),to_char(substrb(dump(min("ISALIVE"),16,0,32),1,120)),to_char(substrb(dump(max("ISALIVE"),16,0,32),1,120)),to_char(count("NOTIFY")),to_char(substrb(dump(min("NOTIFY"),16,0,32),1,120)),to_char(substrb(dump(max("NOTIFY"),16,0,32),1,120)),to_char(count("RTDATA")),to_char(substrb(dump(min("RTDATA"),16,0,32),1,120)),to_char(substrb(dump(max("RTDATA"),16,0,32),1,120)),to_char(count("GROUP")),to_char(substrb(dump(min("GROUP"),16,0,32),1,120)),to_char(substrb(dump(max("GROUP"),16,0,32),1,120)),to_char(count("LASTCHECKHOST")),to_char(substrb(dump(min("LASTCHECKHOST"),16,0,32),1,120)),to_char(substrb(dump(max("LASTCHECKHOST"),16,0,32),1,120)),to_char(count("LASTCHECKTIME")),to_char(substrb(dump(min("LASTCHECKTIME"),16,0,32),1,120)),to_char(substrb(dump(max("LASTCHECKTIME"),16,0,32),1,120)),to_char(count("TOPIC")),to_char(substrb(dump(min("TOPIC"),16,0,32),1,120)),to_char(substrb(dump(max("TOPIC"),16,0,32),1,120)),to_char(count("PARTITION")),to_char(substrb(dump(min("PARTITION"),16,0,32),1,120)),to_char(substrb(dump(max("PARTITION"),16,0,32),1,120)),to_char(count("PRODUCT")),to_char(substrb(dump(min("PRODUCT"),16,0,32),1,120)),to_char(substrb(dump(max("PRODUCT"),16,0,32),1,120)),to_char(count("STATUS")),to_char(substrb(dump(min("STATUS"),16,0,32),1,120)),to_char(substrb(dump(max("STATUS"),16,0,32),1,120)),to_char(count("DB_STORE_ID")),to_char(substrb(dump(min("DB_STORE_ID"),16,0,32),1,120)),to_char(substrb(dump(max("DB_STORE_ID"),16,0,32),1,120)),to_char(count("CHECKSTATUS")),to_char(substrb(dump(min("CHECKSTATUS"),16,0,32),1,120)),to_char(substrb(dump(max("CHECKSTATUS"),16,0,32),1,120)),to_char(count("APPID")),to_char(substrb(dump(min("APPID"),16,0,32),1,120)),to_char(substrb(dump(max("APPID"),16,0,32),1,120)),to_char(count("APPNAME")),to_char(substrb(dump(min("APPNAME"),16,0,32),1,120)),to_char(substrb(dump(max("APPNAME"),16,0,32),1,120)),to_char(count("APPTYPE")),to_char(substrb(dump(min("APPTYPE"),16,0,32),1,120)),to_char(substrb(dump(max("APPTYPE"),16,0,32),1,120)),to_char(count("USERNAME")),to_char(substrb(dump(min("USERNAME"),16,0,32),1,120)),to_char(substrb(dump(max("USERNAME"),16,0,32),1,120)),to_char(count("PASSWORD")),to_char(substrb(dump(min("PASSWORD"),16,0,32),1,120)),to_char(substrb(dump(max("PASSWORD"),16,0,32),1,120)) from "CMDB1"."APP_MONITOR" t  /* NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL*/;

-- 分割线
explain plan set statement_id='1641717057711' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1641453078723' for select * from table(dbms_xplan.display_cursor('as0bnz42tpyuf'));

-- 分割线
explain plan set statement_id='1642056082893' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'bx7tcw6zm75b3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_VIEWS' AND OWNER='SYS';

-- 分割线
explain plan for select * from B where ID =2;

-- 分割线
/*NDTM*/ SELECT F.FILE_ID, F.FILE_NAME, F.TABLESPACE_NAME, ROUND(F.BYTES / 1024 / 1024, 2) FILESIZE, F.BLOCKS, ROUND((F.BYTES - NVL(S.BYTES, 0)) / 1024 / 1024, 2) USED, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND((F.BYTES - nvl(S.BYTES, 0)) / F.BYTES, 4) * 100 ELSE ROUND((F.BYTES - nvl(S.BYTES, 0)) / F.MAXBYTES, 4) * 100 END AS RATIO, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND(F.BYTES / 1024 / 1024, 2) ELSE ROUND(F.MAXBYTES / 1024 / 1024, 2) END AS MAXSIZE, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN F.BLOCKS ELSE F.MAXBLOCKS END AS MAXBLOCKS, F.AUTOEXTENSIBLE, F.ONLINE_STATUS, 'NORMAL' AS TYPES FROM DBA_DATA_FILES F inner join dba_tablespaces t on f.tablespace_name = t.tablespace_name and not t.contents = 'UNDO' LEFT JOIN ( SELECT FILE_ID, SUM(BYTES) BYTES FROM DBA_FREE_SPACE GROUP BY FILE_ID ) S ON F.FILE_ID = S.FILE_ID union all SELECT DTF.FILE_ID, DTF.FILE_NAME, DTF.TABLESPACE_NAME, ROUND(DTF.BYTES / 1024 / 1024, 2) FILESIZE, DTF.BLOCKS, ROUND((t.ub * d.block_size) / 1024 / 1024, 2) USED, CASE DTF.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND((t.ub * d.block_size) / DTF.BYTES * 100, 2) ELSE ROUND((t.ub * d.block_size) / DTF.MAXBYTES * 100, 2) END AS RATIO, CASE DTF.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND(DTF.BYTES / 1024 / 1024, 2) ELSE ROUND(DTF.MAXBYTES / 1024 / 1024, 2) END AS MAXSIZE, CASE DTF.AUTOEXTENSIBLE WHEN 'NO' THEN DTF.BLOCKS ELSE DTF.MAXBLOCKS END AS MAXBLOCKS, DTF.AUTOEXTENSIBLE, DTF.STATUS as ONLINE_STATUS, 'TEMP' AS TYPES FROM DBA_TEMP_FILES DTF, (SELECT ss.tablespace_name, sum(ss.used_blocks) ub FROM gv$sort_segment ss GROUP BY ss.tablespace_name) t, dba_tablespaces d WHERE DTF.tablespace_name = T.tablespace_name and dtf.tablespace_name = d.tablespace_name union all SELECT F.FILE_ID, F.FILE_NAME, F.TABLESPACE_NAME, ROUND(F.BYTES / 1024 / 1024, 2) FILESIZE, F.BLOCKS, ROUND(U.BYTES / 1024 / 1024, 2) USED, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND(U.BYTES / F.BYTES, 4) * 100 ELSE ROUND(U.BYTES / F.MAXBYTES, 4) * 100 END AS RATIO, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN ROUND(F.BYTES / 1024 / 1024, 2) ELSE ROUND(F.MAXBYTES / 1024 / 1024, 2) END AS MAXSIZE, CASE F.AUTOEXTENSIBLE WHEN 'NO' THEN F.BLOCKS ELSE F.MAXBLOCKS END AS MAXBLOCKS, F.AUTOEXTENSIBLE, F.ONLINE_STATUS, 'UNDO' AS TYPES FROM DBA_DATA_FILES F, (SELECT tablespace_name, SUM(bytes) bytes FROM dba_undo_extents where status in ( 'ACTIVE', 'UNEXPIRED' ) GROUP BY tablespace_name) u WHERE F.TABLESPACE_NAME = U.TABLESPACE_NAME;

-- 分割线
explain plan set statement_id='1642056083383' for select * from table(dbms_xplan.display_cursor('4ksy7br58ztqh'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('g4rx52pnt9vuz'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('cuh7k7qdmjts8'));

-- 分割线
explain plan set statement_id='1641885079675' for select * from table(dbms_xplan.display_cursor('bfkda1khvgbab'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1645691396527' for SELECT * FROM ( SELECT TT.*,ROWNUM RN FROM ( select * from TEST_TFY ) TT WHERE ROWNUM < = 050 ) WHERE RN > 0;

-- 分割线
/*NDTM*/select a.* ,b.trans_count from ( select snap_id,instance_number, event_name event,total_waits,total_timeouts,time_waited_micro, wait_class from dba_hist_system_event where event_name not in ('smon timer', 'pmon timer', 'dispatcher timer', 'dispatcher listen timer', 'rdbms ipc message') and snap_id = (select max(snap_id) from dba_hist_sysstat ) ) a left join ( select snap_id,instance_number,sum(value) as trans_count from dba_hist_sysstat where stat_name in ('user rollbacks', 'user commits') group by snap_id,instance_number having snap_id = (select max(snap_id) from dba_hist_sysstat ) ) b on a.snap_id = b.snap_id and a. instance_number = b.instance_number;

-- 分割线
SELECT SUM(DECODE(ROLE, 'SELECT_CATALOG_ROLE', 1, 0)) SELECT_CATALOG_ROLE FROM SYS.SESSION_ROLES WHERE ROLE = 'SELECT_CATALOG_ROLE';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('4pmsm22c0bca5'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1648517493216' for SELECT TIMESTAMP,ID,LPAD(' ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_HASH_VALUE AS PLAN_ID FROM V$SQL_PLAN WHERE SQL_ID = :1 AND PLAN_HASH_VALUE = :2 AND HASH_VALUE = :3 ORDER BY TIMESTAMP,id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('gmsbkakxszhpd'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='4upv74kq1umaq'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1640853003977' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$THREAD' AND OWNER='TESTUSERM';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='fgvsn1yq6su67'and is_obsolete = 'N'  and child_number =0;

-- 分割线
SELECT * FROM (
    SELECT t.*
    FROM C##TEST_HHF.V_TAB_0409A t
) WHERE ROWNUM <= 501;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ALL_TABLES' AND OWNER='SYS';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('390sh29v3sz9x'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('8hpyz6kum7s0b'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-22', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-22', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1645691395491' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='ADMIN';

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-25', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='gq43zfkvh3m7j'and is_obsolete = 'N'  and child_number =0;

-- 分割线
SELECT VALUE FROM SYS.NLS_DATABASE_PARAMETERS WHERE PARAMETER = 'NLS_CHARACTERSET';

-- 分割线
/*
  The name + type results of these queries will be used by the Code Assistant
  if the "Describe Context" option is enabled. After typing 3 or more characters
  the Code Assistant will show a list of matching names.
  Separate multiple queries with semi-colons and use the :schema bind variable
  to restrict names to the currently connected user. 
  In case of an error the query results will be omitted. No error message will
  be displayed.
  Place this file in the PL/SQL Developer installation directory for all users,
  or in the "%APPDATA%\PLSQL Developer" directory for a specific user.
*/
select object_name, object_type
  from sys.all_objects o
 where o.owner = :schema
   and o.object_type in ('TABLE', 'VIEW', 'PACKAGE','TYPE', 'PROCEDURE', 'FUNCTION', 'SEQUENCE')
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('f23sk0grzftpn'));

-- 分割线
explain plan set statement_id='1642056084030' for select * from table(dbms_xplan.display_cursor('c10vdnb4s3mzb'));

-- 分割线
explain plan set statement_id='1645777885747' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='ADMIN';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$PARAMETER' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('7yv2p680r6u4c'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('ac2s4nwbnq3pc'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('gdyjtw861qjfr'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4jhz0n12phzbh'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641544232401' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('008917a6sv3zx'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('6sau6kkvvpzb4'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='2qay7rz6nxy7h'and is_obsolete = 'N'  and child_number =0;

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
SELECT USER FROM SYS.DUAL;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '5v5agnypjkc24' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
SELECT COUNT(*) AS COUNT FROM ( SELECT * FROM TEST.CCC )  TT;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1645777893535' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'gm3ma5u9zg468' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('7kywm7ss6rsn3'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-16', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-16', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-16', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='g0ws1f49b0a27'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$THREAD' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641453079158' for select * from table(dbms_xplan.display_cursor('7bsjfwurah7yd'));

-- 分割线
explain plan set statement_id='1646637406976' for select object_name nam, Decode(object_type, 'TABLE', 1, 'VIEW', 2, 3) typ from sys.user_objects where object_type in ('TABLE','PROCEDURE', 'PACKAGE', 'FUNCTION');

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '4us46xqgststd' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641971529586' for select * from table(dbms_xplan.display_cursor('2m3fr57r0f5xt'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('46utf6h6vmrzj'));

-- 分割线
explain plan set statement_id='1645777883698' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
DECLARE
  TYPE table_names IS VARRAY (3) OF VARCHAR2 (30);
  currval_not_defined          EXCEPTION;
  PRAGMA EXCEPTION_INIT (currval_not_defined, -8002);
  sys_prof_valid               NUMBER;
  toad_prof_valid              NUMBER;
  rst                          NUMBER;
  sys_pack                     VARCHAR2 (17);
  prof_seq                     VARCHAR2 (24);
  tables                       table_names;
  dbms_prof_tables    CONSTANT table_names
    := table_names ('plsql_profiler_data',
                    'plsql_profiler_runs',
                    'plsql_profiler_units') ;
  dbms_hprof_tables   CONSTANT table_names
    := table_names ('dbmshp_runs',
                    'dbmshp_function_info',
                    'dbmshp_parent_child_info') ;
  /*---------------------------------------------------------------------------
  -- Verify that the specified package exists
  ---------------------------------------------------------------------------*/
  FUNCTION CheckPackage (ObjectName IN VARCHAR2)
    RETURN NUMBER
  AS
    valid     NUMBER;
    err_msg   VARCHAR2 (2000);
  BEGIN
    valid := 1;
    BEGIN
      EXECUTE IMMEDIATE 'BEGIN ' || ObjectName || '."363797051932604191928153504"; END;';
    EXCEPTION
      WHEN OTHERS
      THEN
        err_msg := SQLERRM;
        -- If error is for missing package member then we are OK
        IF INSTR (err_msg, 'PLS-00302') > 0
        THEN
          valid := 1;
        ELSE
          valid := 0;
        END IF;
    END;
    RETURN valid;
  END;
BEGIN
  IF :check_hierarchical = 0
  THEN
    tables := dbms_prof_tables;
    sys_pack := 'sys.dbms_profiler';
    prof_seq := 'plsql_profiler_runnumber';
  ELSE
    tables := dbms_hprof_tables;
    sys_pack := 'sys.dbms_hprof';
    prof_seq := 'dbmshp_runnumber';
  END IF;
  -- Check for the SYS.DBMS_PROFILER package
  sys_prof_valid := CheckPackage (sys_pack);
  -- If it exists, check for the other profiler objects
  IF sys_prof_valid = 1
  THEN
    toad_prof_valid := 1;
    BEGIN
      -- Check for all tables
      FOR i IN tables.FIRST .. tables.LAST
      LOOP
        BEGIN
          EXECUTE IMMEDIATE 'SELECT 1 FROM ' || tables (i) || ' WHERE 0 = 1'
            INTO rst;
        EXCEPTION
          WHEN NO_DATA_FOUND
          THEN
            toad_prof_valid := 1;
          WHEN OTHERS
          THEN
            RAISE;
        END;
      END LOOP;
      -- Check for the sequence
      BEGIN
        EXECUTE IMMEDIATE 'SELECT ' || prof_seq || '.currval FROM DUAL';
      EXCEPTION
        WHEN currval_not_defined
        THEN
          toad_prof_valid := 1;
        WHEN OTHERS
        THEN
          RAISE;
      END;
      -- Check for the TOAD_PROFILER package
      IF :check_hierarchical <> 1
      THEN
        toad_prof_valid := CheckPackage ('toad_profiler');
      END IF;
    EXCEPTION
      WHEN OTHERS
      THEN
        toad_prof_valid := 0;
    END;
  ELSE
    toad_prof_valid := 0;
  END IF;
  :out_sys_prof_valid := sys_prof_valid;
  :out_toad_prof_valid := toad_prof_valid;
END;;

-- 分割线
explain plan set statement_id='1641889880510' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'B' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1646731688054' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='TESTUSERM';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='4us46xqgststd'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$ARCHIVE_DEST_STATUS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640934725372' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7z6wnb12pqacz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('fyfuk6j14v83w'));

-- 分割线
explain plan set statement_id='1648543649122' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('6kxm4k8uznf7n'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-15', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641889868918' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641521237120' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641885079597' for select * from table(dbms_xplan.display_cursor('9rvd8qx86gz36'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5gmfdfuu8s3y9'));

-- 分割线
explain plan set statement_id='1640853001769' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641883274915' for select * from table(dbms_xplan.display_cursor('5ctkrx7wpcx7t'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='c3c0ugvm3qp4w'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'B' AND OWNER='TEST1';

-- 分割线
declare
  Lines sys.dbms_output.chararr;
begin
  :NumLines := 10;
  sys.dbms_output.get_lines(lines => Lines, numlines => :NumLines);
  if :NumLines > 0 then :Line0 := Lines(1); end if;
  if :NumLines > 1 then :Line1 := Lines(2); end if;
  if :NumLines > 2 then :Line2 := Lines(3); end if;
  if :NumLines > 3 then :Line3 := Lines(4); end if;
  if :NumLines > 4 then :Line4 := Lines(5); end if;
  if :NumLines > 5 then :Line5 := Lines(6); end if;
  if :NumLines > 6 then :Line6 := Lines(7); end if;
  if :NumLines > 7 then :Line7 := Lines(8); end if;
  if :NumLines > 8 then :Line8 := Lines(9); end if;
  if :NumLines > 9 then :Line9 := Lines(10); end if;
end;
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('4rqn46b1sfmzt'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'USER$' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('0z16b9a7jg1fd'));

-- 分割线
SELECT COUNT('x') FROM SYS.ALL_TABLES WHERE OWNER IN ('TOAD', USER) AND TABLE_NAME IN ('CX_XPERTRUN', 'CX_XPERTLINES', 'CX_XPERTITEMS', 'CX_TYPES', 'CX_SEVERITYS', 'CX_SETRULES', 'CX_RULESETS', 'CX_METRICS', 'CX_METRICRANGES', 'CX_CATEGORYS', 'CX_BASERULES');

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641889872189' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'T1' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1641285062539' for select * from table(dbms_xplan.display_cursor('70w2qtpvh2y10'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-09', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '4upv74kq1umaq' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('6bkq8srdjns6v'));

-- 分割线
explain plan set statement_id='1648517493308' for select line||':'||position||':'||text as message from sys.all_errors where type = 'TABLE' and owner = :1 and name = :2 order by sequence;

-- 分割线
select  * from table(dbms_xplan.display_cursor('bx7tcw6zm75b3'));

-- 分割线
explain plan set statement_id='1641883293186' for select * from table(dbms_xplan.display_cursor('66r41s9493sdd'));

-- 分割线
explain plan set statement_id='1648543645503' for SELECT VALUE FROM V$PARAMETER WHERE NAME = 'cluster_database';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641544227598' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1648517491605' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'fgvsn1yq6su67' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641803429353' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1646731690891' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_EXTERNAL_TABLES' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('a9yp2pbzx7hy2'));

-- 分割线
explain plan set statement_id='1640934725261' for select * from table(dbms_xplan.display_cursor('034j8nxagtz7x'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('cx60sck6yygkd'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641544228710' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('6b1n01pnmanbt'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='f23sk0grzftpn'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1642056081676' for select * from table(dbms_xplan.display_cursor('4ksy7br58ztqh'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST_TFY' AND OWNER='ADMIN';

-- 分割线
SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION ;

-- 分割线
select  * from table(dbms_xplan.display_cursor('ddrx31kvkt7bg'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('gu6ytbj2gxwxr'));

-- 分割线
explain plan set statement_id='1642056083435' for select * from table(dbms_xplan.display_cursor('4882s0h26pd5v'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4upv74kq1umaq'));

-- 分割线
explain plan set statement_id='1641453075401' for select * from table(dbms_xplan.display_cursor('6sau6kkvvpzb4'));

-- 分割线
explain plan set statement_id='1642056082956' for select * from table(dbms_xplan.display_cursor('fsw8111ja9wbd'));

-- 分割线
/* SQL Analyze(0) */ select /*+  full(t)    no_parallel(t) no_parallel_index(t) dbms_stats cursor_sharing_exact use_weak_name_resl dynamic_sampling(0) no_monitoring no_substrb_pad  */to_char(count("AL_KEY")),to_char(substrb(dump(min("AL_KEY"),16,0,32),1,120)),to_char(substrb(dump(max("AL_KEY"),16,0,32),1,120)),to_char(count("DBINC_KEY")),to_char(substrb(dump(min("DBINC_KEY"),16,0,32),1,120)),to_char(substrb(dump(max("DBINC_KEY"),16,0,32),1,120)),to_char(count("AL_RECID")),to_char(substrb(dump(min("AL_RECID"),16,0,32),1,120)),to_char(substrb(dump(max("AL_RECID"),16,0,32),1,120)),to_char(count("AL_STAMP")),to_char(substrb(dump(min("AL_STAMP"),16,0,32),1,120)),to_char(substrb(dump(max("AL_STAMP"),16,0,32),1,120)),to_char(count("THREAD#")),to_char(substrb(dump(min("THREAD#"),16,0,32),1,120)),to_char(substrb(dump(max("THREAD#"),16,0,32),1,120)),to_char(count("SEQUENCE#")),to_char(substrb(dump(min("SEQUENCE#"),16,0,32),1,120)),to_char(substrb(dump(max("SEQUENCE#"),16,0,32),1,120)),to_char(count("LOW_SCN")),to_char(substrb(dump(min("LOW_SCN"),16,0,32),1,120)),to_char(substrb(dump(max("LOW_SCN"),16,0,32),1,120)),to_char(count("LOW_TIME")),to_char(substrb(dump(min("LOW_TIME"),16,0,32),1,120)),to_char(substrb(dump(max("LOW_TIME"),16,0,32),1,120)),to_char(count("NEXT_SCN")),to_char(substrb(dump(min("NEXT_SCN"),16,0,32),1,120)),to_char(substrb(dump(max("NEXT_SCN"),16,0,32),1,120)),to_char(count("NEXT_TIME")),to_char(substrb(dump(min("NEXT_TIME"),16,0,32),1,120)),to_char(substrb(dump(max("NEXT_TIME"),16,0,32),1,120)),to_char(count("FNAME")),to_char(substrb(dump(min("FNAME"),16,0,32),1,120)),to_char(substrb(dump(max("FNAME"),16,0,32),1,120)),to_char(count("FNAME_HASHKEY")),to_char(substrb(dump(min("FNAME_HASHKEY"),16,0,32),1,120)),to_char(substrb(dump(max("FNAME_HASHKEY"),16,0,32),1,120)),to_char(count("ARCHIVED")),to_char(substrb(dump(min("ARCHIVED"),16,0,32),1,120)),to_char(substrb(dump(max("ARCHIVED"),16,0,32),1,120)),to_char(count("BLOCKS")),to_char(substrb(dump(min("BLOCKS"),16,0,32),1,120)),to_char(substrb(dump(max("BLOCKS"),16,0,32),1,120)),to_char(count("BLOCK_SIZE")),to_char(substrb(dump(min("BLOCK_SIZE"),16,0,32),1,120)),to_char(substrb(dump(max("BLOCK_SIZE"),16,0,32),1,120)),to_char(count("COMPLETION_TIME")),to_char(substrb(dump(min("COMPLETION_TIME"),16,0,32),1,120)),to_char(substrb(dump(max("COMPLETION_TIME"),16,0,32),1,120)),to_char(count("IS_STANDBY")),to_char(substrb(dump(min("IS_STANDBY"),16,0,32),1,120)),to_char(substrb(dump(max("IS_STANDBY"),16,0,32),1,120)),to_char(count("STATUS")),to_char(substrb(dump(min("STATUS"),16,0,32),1,120)),to_char(substrb(dump(max("STATUS"),16,0,32),1,120)),to_char(count("DICTIONARY_BEGIN")),to_char(substrb(dump(min("DICTIONARY_BEGIN"),16,0,32),1,120)),to_char(substrb(dump(max("DICTIONARY_BEGIN"),16,0,32),1,120)),to_char(count("DICTIONARY_END")),to_char(substrb(dump(min("DICTIONARY_END"),16,0,32),1,120)),to_char(substrb(dump(max("DICTIONARY_END"),16,0,32),1,120)),to_char(count("IS_RECOVERY_DEST_FILE")),to_char(substrb(dump(min("IS_RECOVERY_DEST_FILE"),16,0,32),1,120)),to_char(substrb(dump(max("IS_RECOVERY_DEST_FILE"),16,0,32),1,120)),to_char(count("COMPRESSED")),to_char(substrb(dump(min("COMPRESSED"),16,0,32),1,120)),to_char(substrb(dump(max("COMPRESSED"),16,0,32),1,120)),to_char(count("CREATOR")),to_char(substrb(dump(min("CREATOR"),16,0,32),1,120)),to_char(substrb(dump(max("CREATOR"),16,0,32),1,120)),to_char(count("TERMINAL")),to_char(substrb(dump(min("TERMINAL"),16,0,32),1,120)),to_char(substrb(dump(max("TERMINAL"),16,0,32),1,120)),to_char(count("SITE_KEY")),to_char(substrb(dump(min("SITE_KEY"),16,0,32),1,120)),to_char(substrb(dump(max("SITE_KEY"),16,0,32),1,120)) from "CATALOGUSER"."AL" t  /* ACL,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL,NDV,NIL,NIL*/;

-- 分割线
select  * from table(dbms_xplan.display_cursor('guvkph4gp6ht7'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='8vh13jzta9rrj'and is_obsolete = 'N'  and child_number =0;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-22', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'f23sk0grzftpn' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('cjm8v8sy32sab'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TABLES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1646731688425' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641717059908' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'a9gdjxq7tkgnz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('g6xft50y2wfsq'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1646731691939' for select 'x' from dual;

-- 分割线
explain plan set statement_id='1640934694387' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '1ffz3bawxyajj' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COMMENTS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641883274147' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'gj89hnjp4nz3y' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1640852999729' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
SELECT SUM(DECODE(PRIVILEGE, 'DEBUG CONNECT SESSION', 1, 0)) DEBUG_CONNECT_SESSION, SUM(DECODE(PRIVILEGE, 'ALTER SESSION', 1, 0)) ALTER_SESSION, SUM(DECODE(PRIVILEGE, 'ALTER SYSTEM', 1, 0)) ALTER_SYSTEM, SUM(DECODE(PRIVILEGE, 'ALTER DATABASE', 1, 0)) ALTER_DATABASE, SUM(DECODE(PRIVILEGE, 'SELECT ANY TABLE', 1, 0)) SELECT_ANY_TABLE, SUM(DECODE(PRIVILEGE, 'UPDATE ANY TABLE', 1, 0)) UPDATE_ANY_TABLE, SUM(DECODE(PRIVILEGE, 'GRANT ANY OBJECT PRIVILEGE', 1, 0)) GRANT_ANY_OBJECT_PRIV, SUM(DECODE(PRIVILEGE, 'SELECT ANY DICTIONARY', 1, 0)) SELECT_ANY_DICTIONARY, SUM(DECODE(PRIVILEGE, 'CREATE PUBLIC SYNONYM', 1, 0)) CREATE_PUBLIC_SYN FROM SYS.SESSION_PRIVS WHERE PRIVILEGE IN ('DEBUG CONNECT SESSION', 'ALTER SESSION', 'ALTER SYSTEM', 'ALTER DATABASE', 'SELECT ANY TABLE', 'UPDATE ANY TABLE', 'GRANT ANY OBJECT PRIVILEGE', 'SELECT ANY DICTIONARY', 'CREATE PUBLIC SYNONYM');

-- 分割线
select  * from table(dbms_xplan.display_cursor('3wphvwq1fsuz4'));

-- 分割线
/*NDTM*/SELECT A.*, END_INTERVAL_TIME FROM ( SELECT SNAP_ID, INSTANCE_NUMBER, STAT_NAME , ROUND(VALUE / 1000000, 2) AS SECONDS FROM DBA_HIST_SYS_TIME_MODEL WHERE SNAP_ID = ( SELECT MAX(SNAP_ID) FROM DBA_HIST_WAITSTAT ) ) A LEFT JOIN ( SELECT SNAP_ID, INSTANCE_NUMBER, END_INTERVAL_TIME FROM DBA_HIST_SNAPSHOT WHERE SNAP_ID = ( SELECT MAX(SNAP_ID) FROM DBA_HIST_SYS_TIME_MODEL ) ) B ON A.SNAP_ID = B.SNAP_ID AND A.INSTANCE_NUMBER=B.INSTANCE_NUMBER;

-- 分割线
explain plan set statement_id='1641112259151' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1641717061732' for select * from table(dbms_xplan.display_cursor('4y13nt40f64jd'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5h1uvduvxk4yc'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'T' AND OWNER='ADMIN';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_USERS' AND OWNER='SYS';

-- 分割线
/*NDTM*/ SELECT b.OWNER, a.object_name, a.CREATED, a.LAST_DDL_TIME, b.STATUS, b.TRIGGER_BODY FROM SYS.ALL_OBJECTS a inner JOIN SYS.dba_triggers b ON a.object_name = b.trigger_name WHERE b.OWNER NOT IN('SYS', 'XDB', 'GSMADMIN_INTERNAL', 'WMSYS', 'MDSYS', 'LBACSYS', 'SYSTEM', 'EXFSYS', 'OLAPSYS', 'SYSMAN') and b.OWNER is not null and b.trigger_name is not null;

-- 分割线
explain plan set statement_id='1641521229175' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_CONSTRAINTS' AND OWNER='SYS';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'PLAN_TABLE' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('87rvzr13t7gdc'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('0hun19w55yqv6'));

-- 分割线
select sid, serial# from v$session where audsid = userenv('SESSIONID')
;

-- 分割线
explain plan set statement_id='1646637406359' for select object_name from sys.all_procedures where owner = 'RDSADMIN' and object_name = 'RDSADMIN_UTIL' and object_type = 'PACKAGE' and subprogram_id = 0;

-- 分割线
explain plan set statement_id='1641521234993' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('f6cgh73251q7u'));

-- 分割线
explain plan set statement_id='1641717061761' for select * from table(dbms_xplan.display_cursor('07hfy8b1gjp9f'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-13', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1642056088758' for select * from table(dbms_xplan.display_cursor('22x8t0a3dccy4'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('2a1m18vrcmmay'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('04aa4upv3asqu'));

-- 分割线
explain plan set statement_id='1642056084224' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddtyj7madmut2' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_CONSTRAINTS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1642056088569' for select * from table(dbms_xplan.display_cursor('7yv2p680r6u4c'));

-- 分割线
explain plan set statement_id='1641717055848' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST_1';

-- 分割线
/*NDTM*/ select * from (SELECT B.OWNER AS OWNER, SEGMENT_NAME AS SEGMENT_NAME, nvl( PARTITION_NAME, '-' ) AS PARTITION_NAME, SEGMENT_TYPE AS SEGMENT_TYPE, SEGMENT_SUBTYPE AS SEGMENT_SUBTYPE, TABLESPACE_NAME AS TABLESPACE_NAME, HEADER_FILE AS HEADER_FILE, HEADER_BLOCK AS HEADER_BLOCK, BYTES AS BYTES, BLOCKS AS BLOCKS, EXTENTS AS EXTENTS, INITIAL_EXTENT AS INITIAL_EXTENT, NEXT_EXTENT AS NEXT_EXTENT, MIN_EXTENTS AS MIN_EXTENTS, MAX_EXTENTS AS MAX_EXTENTS, MAX_SIZE AS MAX_SIZE, RETENTION AS RETENTION, MINRETENTION AS MINRETENTION, PCT_INCREASE AS PCT_INCREASE, FREELISTS AS FREELISTS, FREELIST_GROUPS AS FREELIST_GROUPS, RELATIVE_FNO AS RELATIVE_FNO, BUFFER_POOL AS BUFFER_POOL, FLASH_CACHE AS FLASH_CACHE FROM DBA_OBJECTS A, DBA_SEGMENTS B WHERE A.OWNER = B.OWNER AND A.OBJECT_NAME = B.SEGMENT_NAME AND nvl( A.SUBOBJECT_NAME, '-' ) = nvl( PARTITION_NAME, '-' ) AND B.OWNER NOT IN ( 'DBSNMP', 'SYSMAN', 'FLOWS_FILES', 'MDSYS', 'ORDSYS', 'EXFSYS', 'WMSYS', 'APPQOSSYS', 'APEX_030200', 'OWBSYS_AUDIT', 'ORDDATA', 'CTXSYS', 'ANONYMOUS', 'XDB', 'ORDPLUGINS', 'OWBSYS', 'SI_INFORMTN_SCHEMA', 'OLAPSYS', 'MGMT_VIEW', 'SYS', 'SYSTEM', 'OUTLN', 'DIP', 'ORACLE_OCM', 'XS$NULL', 'SQLTXPLAIN' ) order by BYTES desc) T where ROWNUM <= 100;

-- 分割线
explain plan set statement_id='1642056083779' for select * from table(dbms_xplan.display_cursor('g1s2cw6sr8q3s'));

-- 分割线
explain plan set statement_id='1646702437135' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TABLES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641717055526' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST_1';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST';

-- 分割线
select SYS_CONTEXT('USERENV','SID') sid, sysdate from dual;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_USERS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641521236909' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('8vu2vkmgwz1y0'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5r3gskq6wjfyt'));

-- 分割线
explain plan set statement_id='1640853004163' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641521235415' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
select value from v$sesstat where sid = :sid order by statistic#
;

-- 分割线
SELECT USER FROM SYS.USER_OBJECTS WHERE OBJECT_NAME = 'QU_VERSION' AND OBJECT_TYPE IN ('PACKAGE', 'SYNONYM') AND ROWNUM = 1;

-- 分割线
SELECT *  FROM ( SELECT TT.*,ROWNUM  RN FROM ( 
select * from T1 ) TT WHERE ROWNUM < = 050 ) WHERE RN > 0;

-- 分割线
explain plan set statement_id='1648543645347' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641803442610' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'dr3c9qa3x56db' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646637406924' for SELECT USER FROM SYS.DUAL;

-- 分割线
explain plan set statement_id='1641453078694' for select * from table(dbms_xplan.display_cursor('gdrvwsf3jpcvk'));

-- 分割线
explain plan set statement_id='1648543646719' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1646702444928' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$DATAGUARD_STATS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641889875371' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST_TFY' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641285061823' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='g914mamrdszq7'and is_obsolete = 'N' and child_number =0;

-- 分割线
explain plan set statement_id='1646637406869' for select sys_context('USERENV','INSTANCE_NAME'), sys_context('USERENV','SERVER_HOST') from dual;

-- 分割线

select * from T1;

-- 分割线
select  * from table(dbms_xplan.display_cursor('fs4ym5u7p555f'));

-- 分割线
explain plan set statement_id='1642056083051' for select * from table(dbms_xplan.display_cursor('7ydsphbhu59hm'));

-- 分割线
explain plan set statement_id='1648543646111' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641453075041' for select * from table(dbms_xplan.display_cursor('7bsjfwurah7yd'));

-- 分割线
explain plan set statement_id='1641976269617' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2pyxt8v955cpr' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641971531987' for select * from table(dbms_xplan.display_cursor('ddckhcpm1av42'));

-- 分割线
explain plan set statement_id='1642062665563' for select * from table(dbms_xplan.display_cursor('4ksy7br58ztqh'));

-- 分割线
explain plan set statement_id='1642056086892' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'bx7tcw6zm75b3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1640853004292' for SELECT * FROM NLS_SESSION_PARAMETERS;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'NLS_SESSION_PARAMETERS' AND OWNER='TESTUSERM';

-- 分割线
/*NDTM*/select owner,table_name,count(table_name) over() as num_count from dba_tables where table_name not in (select table_name from dba_indexes);

-- 分割线
explain plan set statement_id='1646637406562' for SELECT COUNT('x') FROM SYS.ALL_TABLES WHERE OWNER IN ('TOAD', USER) AND TABLE_NAME IN ('CX_XPERTRUN', 'CX_XPERTLINES', 'CX_XPERTITEMS', 'CX_TYPES', 'CX_SEVERITYS', 'CX_SETRULES', 'CX_RULESETS', 'CX_METRICS', 'CX_METRICRANGES', 'CX_CATEGORYS', 'CX_BASERULES');

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641885101951' for select * from table(dbms_xplan.display_cursor('0z16b9a7jg1fd'));

-- 分割线
explain plan set statement_id='1642056083752' for select * from table(dbms_xplan.display_cursor('fyjgn1shxgp93'));

-- 分割线
explain plan set statement_id='1645777886846' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='dtbp8qkxufjgk'and is_obsolete = 'N' and child_number =0;

-- 分割线
explain plan set statement_id='1648517493102' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1646731687556' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  * from table(dbms_xplan.display_cursor('958dh0014w3g2'));

-- 分割线
explain plan set statement_id='1641889864081' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('c6cbwvdw329bs'));

-- 分割线
explain plan set statement_id='1641885100391' for select * from table(dbms_xplan.display_cursor('bfkda1khvgbab'));

-- 分割线
explain plan set statement_id='1645777894078' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '4bggnvq4b8cy3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641883275045' for select * from table(dbms_xplan.display_cursor('8x2qvbxjkptd1'));

-- 分割线
explain plan set statement_id='1641885079558' for select * from table(dbms_xplan.display_cursor('cuh7k7qdmjts8'));

-- 分割线
explain plan set statement_id='1641453079644' for select * from table(dbms_xplan.display_cursor('92vpc4c5a20hy'));

-- 分割线
explain plan set statement_id='1641453078962' for select * from table(dbms_xplan.display_cursor('fth9t8yspfn8x'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('3nn0ctn4z5csf'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$PARAMETER' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('96ta79ncsthc1'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('2qay7rz6nxy7h'));

-- 分割线
explain plan set statement_id='1640853004072' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$ARCHIVED_LOG' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640856674420' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641521220670' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
declare
  c integer := 0;
  p1 varchar2(500);
  p2 varchar2(500);
  expr varchar2(500);
  dblink varchar2(500);
  part1_type integer;
  object_number integer;
  dp integer;
  guard_error exception;
  pragma exception_init(guard_error, -16224);
begin
  :object_type := null;
  :object_owner := null;
  :object_name := null;
  :sub_object := null;
  expr := :part1;
  if :part2 is not null then expr := expr || '.' || :part2; end if;
  if :part3 is not null then expr := expr || '.' || :part3; end if;
  loop
    begin
      sys.dbms_utility.name_resolve(name => expr,
                                    context => c,
                                    schema => :object_owner,
                                    part1 => p1,
                                    part2 => p2,
                                    dblink => dblink,
                                    part1_type => part1_type,
                                    object_number => object_number);
      if part1_type = 1 then :object_type := 'INDEX'; end if;
      if part1_type = 2 then :object_type := 'TABLE'; end if;
      if part1_type = 4 then :object_type := 'VIEW'; end if;
      if part1_type = 5 then :object_type := 'SYNONYM'; end if;
      if part1_type = 6 then :object_type := 'SEQUENCE'; end if;
      if part1_type = 7 then :object_type := 'PROCEDURE'; end if;
      if part1_type = 8 then :object_type := 'FUNCTION'; end if;
      if part1_type = 9 then :object_type := 'PACKAGE'; end if;
      if part1_type = 12 then :object_type := 'TRIGGER'; end if;
      if part1_type = 13 then :object_type := 'TYPE'; end if;
      if part1_type = 28 then :object_type := 'JAVA SOURCE'; end if;
      if part1_type = 29 then :object_type := 'JAVA CLASS'; end if;
      if :object_type is null then
        select object_type into :object_type
          from sys.all_objects
         where object_id = object_number;
      end if;
    exception
      when guard_error then
        raise;
      when others then
        null;
    end;
    c := c + 1;
    if c > 9 then
      dp := instr(expr, '.', -1);
      if dp > 0 then
        if :sub_object is not null then
          :sub_object := '.' || :sub_object;
        end if;
        :sub_object := upper(substr(expr, dp + 1)) || :sub_object;
        expr := substr(expr, 1, dp - 1);
        c := 0;
      end if; 
    end if;
    exit when (:object_type is not null) or (c > 9);
  end loop;
  if :object_type is not null then
    if p1 is null then
      :object_name := p2;
    elsif p2 is null then
      :object_name := p1;
      if :object_name = :part1 and :part2 is not null then
        :sub_object := :part2;
      end if;
      if :object_name = :part2 and :part3 is not null then
        :sub_object := :part3;
      end if;   
    else
      :object_name := p1;
      :sub_object := p2;
    end if;
    return;
  end if;
  begin
    if :part2 is null and :part3 is null then
      select 'USER', null, :part1
        into :object_type, :object_owner, :object_name
        from sys.all_users u
       where u.username = :part1
         and rownum = 1;
      return;
    end if;
  exception
    when no_data_found then
      null;
  end;
  begin
    if :part2 is null and :part3 is null and :deep != 0 then
      select 'ROLE', null, :part1
        into :object_type, :object_owner, :object_name
        from sys.session_roles r
       where r.role = :part1
         and rownum = 1;
      return;
    end if;
  exception
    when no_data_found then
      null;
  end;  
  if :deep != 0 then
    begin
      if :part2 is null then
        select constraint_type, owner, constraint_name
          into :object_type, :object_owner, :object_name
          from sys.all_constraints c
         where c.constraint_name = :part1
           and c.owner = :cur_schema
           and rownum = 1;
      else
        select constraint_type, owner, constraint_name, :part3
          into :object_type, :object_owner, :object_name, :sub_object
          from sys.all_constraints c
         where c.constraint_name = :part2
           and c.owner = :part1
           and rownum = 1;
      end if;
      if :object_type = 'P' then
        :object_type := 'PRIMARY KEY';
      end if;
      if :object_type = 'U' then
        :object_type := 'UNIQUE KEY';
      end if;
      if :object_type = 'R' then
        :object_type := 'FOREIGN KEY';
      end if;
      if :object_type = 'C' then
        :object_type := 'CHECK CONSTRAINT';
      end if;
      return;
    exception
      when no_data_found then
        null;
    end;
  end if;
end;
;

-- 分割线
explain plan set statement_id='1641889880735' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'B' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1642056082456' for select * from table(dbms_xplan.display_cursor('c10vdnb4s3mzb'));

-- 分割线
explain plan set statement_id='1641889864869' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST_TFY' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('avh86urnpa9hx'));

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log  where completion_time > sysdate - 2 order by  2,3,4;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$ARCHIVE_DEST_STATUS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640856683133' for select * from table(dbms_xplan.display_cursor('af5ma8j9sfs77'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('109fu4qm570c6'));

-- 分割线
explain plan set statement_id='1640856674263' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$PARAMETER' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1642062667836' for select * from table(dbms_xplan.display_cursor('7ydsphbhu59hm'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2cwb7bzq4xs47'));

-- 分割线

select * from TEST_TFY;

-- 分割线
explain plan set statement_id='1641453079780' for select * from table(dbms_xplan.display_cursor('dj0vzkumjbavu'));

-- 分割线
explain plan set statement_id='1640766682281' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from v$archived_log where sequence#=27622;

-- 分割线
explain plan set statement_id='1642056083877' for select * from table(dbms_xplan.display_cursor('49ww0cvch2b6w'));

-- 分割线
select  * from  v$archived_log;

-- 分割线
SELECT V.VIEW_NAME, V.OWNER, (SELECT STATUS FROM SYS.ALL_OBJECTS WHERE OWNER = V.OWNER AND OBJECT_NAME = V.VIEW_NAME AND OBJECT_TYPE = 'VIEW' AND SUBOBJECT_NAME IS NULL) STATUS FROM SYS.ALL_VIEWS V WHERE V.OWNER = 'TEST' ORDER BY V.OWNER, V.VIEW_NAME ASC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('43h7znn2n6phg'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddtyj7madmut2' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640853003435' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('17whwmct115jd'));

-- 分割线
explain plan set statement_id='1641971520811' for select * from table(dbms_xplan.display_cursor('2ywu62ss6z6bk'));

-- 分割线
 select DEST_ID, STATUS, DESTINATION, ERROR from V$ARCHIVE_DEST where DEST_ID<=6
;

-- 分割线
explain plan set statement_id='1640934696099' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '84crq17m8xs07' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1640934719599' for select * from table(dbms_xplan.display_cursor('416w8vpr6tq9v'));

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1640934727544' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2cwb7bzq4xs47' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('8w117s58rxmm8'));

-- 分割线
explain plan set statement_id='1640934695467' for select * from table(dbms_xplan.display_cursor('7ff8v0jvhvjr5'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('7j011s5pbj837'));

-- 分割线
explain plan set statement_id='1641453079016' for select * from table(dbms_xplan.display_cursor('6bkq8srdjns6v'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'PLAN_TABLE' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641883275707' for select * from table(dbms_xplan.display_cursor('66r41s9493sdd'));

-- 分割线
explain plan set statement_id='1646731687469' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TT' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1641883278040' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  * from table(dbms_xplan.display_cursor('a1tgpg3y1mj2x'));

-- 分割线
explain plan set statement_id='1640766682400' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from v$archived_log where completion_time > sysdate - 1 order by 2,3,4;

-- 分割线
select  * from table(dbms_xplan.display_cursor('b1vvw5zzhyg5p'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'USER_OBJECTS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641453074982' for select * from table(dbms_xplan.display_cursor('6s1wpny5b309n'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_MVIEWS' AND OWNER='TEST';

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '9am4sfvrsw1jb' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646637405826' for select object_name nam, Decode(object_type, 'TABLE', 1, 'VIEW', 2, 3) typ from sys.user_objects where object_type in ('TABLE','PROCEDURE', 'PACKAGE', 'FUNCTION');

-- 分割线
explain plan set statement_id='1641971528336' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2pyxt8v955cpr' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1628737274174' for SELECT MV.MVIEW_NAME FROM ALL_MVIEWS MV, ALL_TABLES T WHERE MV.OWNER = T.OWNER AND MV.MVIEW_NAME = T.TABLE_NAME AND MV.OWNER = 'TEST' ORDER BY MV.MVIEW_NAME ASC;

-- 分割线
select * from T1;

-- 分割线
SELECT * FROM TEST.CCC;

-- 分割线
explain plan set statement_id='1648537936829' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1642056084055' for select * from table(dbms_xplan.display_cursor('4arz2270pv6q0'));

-- 分割线
explain plan set statement_id='1646731687532' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('1pascr25jc6mz'));

-- 分割线
explain plan set statement_id='1641453079914' for select * from table(dbms_xplan.display_cursor('6sau6kkvvpzb4'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DUAL' AND OWNER='TESTUSERM';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='gu6ytbj2gxwxr'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('gdrvwsf3jpcvk'));

-- 分割线
explain plan set statement_id='1640934694553' for select * from table(dbms_xplan.display_cursor('36tg05vux1y1v'));

-- 分割线
explain plan set statement_id='1641803450166' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '1d4qmp3jjhv11' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641883292333' for select * from table(dbms_xplan.display_cursor('3wphvwq1fsuz4'));

-- 分割线
explain plan set statement_id='1648457196926' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1642062666175' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddtyj7madmut2' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select * From v$flash_recovery_area_usage
;

-- 分割线
explain plan set statement_id='1641717061201' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'a8wf8ymgmwfcw' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1642056082443' for select * from table(dbms_xplan.display_cursor('2f4n9f18uba5v'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('as870xurrmqfs'));

-- 分割线
explain plan set statement_id='1641453078640' for select * from table(dbms_xplan.display_cursor('bv6664dgbb9cg'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$DATAGUARD_STATS' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641889879253' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'T' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('g1j4gnu80vf6h'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1640766681010' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from v$archived_log where sequence#=27851;

-- 分割线

select s.synonym_name as object_name, o.object_type
  from sys.all_synonyms s, sys.all_objects o
 where s.owner in ('PUBLIC', :schema)
   and o.owner = s.table_owner
   and o.object_name = s.table_name
   and o.object_type in ('TABLE', 'VIEW', 'PACKAGE','TYPE', 'PROCEDURE', 'FUNCTION', 'SEQUENCE')
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('8thk2zwug4pf5'));

-- 分割线
explain plan set statement_id='1646731688762' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_VIEWS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1640853021005' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ extractvalue(xmlval, '/*/info[@type = "sql_profile"]'), extractvalue(xmlval, '/*/info[@type = "sql_patch"]'), extractvalue(xmlval, '/*/info[@type = "baseline"]'), extractvalue(xmlval, '/*/info[@type = "outline"]'), extractvalue(xmlval, '/*/info[@type = "dynamic_sampling"]'), extractvalue(xmlval, '/*/info[@type = "dop"]'), extractvalue(xmlval, '/*/info[@type = "dop_reason"]'), extractvalue(xmlval, '/*/info[@type = "queuing_reason"]'), extractvalue(xmlval, '/*/info[@type = "row_shipping"]'), extractvalue(xmlval, '/*/info[@type = "index_size"]'), extractvalue(xmlval, '/*/info[@type = "result_checksum"]'), extractvalue(xmlval, '/*/info[@type = "cardinality_feedback"]'), extractvalue(xmlval, '/*/info[@type = "xml_suboptimal"]'), extractvalue(xmlval,'/*/info[@type = "plan_hash"]') from (select xmltype(:1 ) xmlval from dual);

-- 分割线
SELECT * FROM (
    SELECT t.*, ROWID
    FROM C##TEST_HHF.TAB_0409A t
) WHERE ROWNUM <= 501;

-- 分割线
explain plan set statement_id='1641883286167' for select * from table(dbms_xplan.display_cursor('5ctkrx7wpcx7t'));

-- 分割线
explain plan set statement_id='1645691395704' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TT' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1642056088785' for select * from table(dbms_xplan.display_cursor('7ydsphbhu59hm'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4us46xqgststd'));

-- 分割线
BEGIN DBMS_OUTPUT.DISABLE; END;;

-- 分割线
explain plan set statement_id='1640934696129' for select * from table(dbms_xplan.display_cursor('gap4kn6ahbgky'));

-- 分割线
explain plan set statement_id='1641803453920' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '40n6gqn2y6r12' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('4appyc9ufxvkt'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DUAL' AND OWNER='ADMIN';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'PLAN_TABLE' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('c3c0ugvm3qp4w'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'USER_OBJECTS' AND OWNER='SYS';

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log  where sequence#=27622;

-- 分割线
explain plan set statement_id='1646731688840' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST123' AND OWNER='TEST';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_PROCEDURES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1640934731366' for select * from table(dbms_xplan.display_cursor('7z6wnb12pqacz'));

-- 分割线
explain plan set statement_id='1641717061871' for select * from table(dbms_xplan.display_cursor('87djs45pbbqa2'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4k4ud342rqqb1'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='DBMON';

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2a1m18vrcmmay' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641453079297' for select * from table(dbms_xplan.display_cursor('ccczh528wha7w'));

-- 分割线
explain plan set statement_id='1648543648160' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2wtud18rngt6z'));

-- 分割线
SELECT * FROM v$recovery_file_dest
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('g2qcfq151ff34'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddrx31kvkt7bg' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST_TFY' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1645777886129' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$PARAMETER' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1640853003088' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$ARCHIVED_LOG' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1648543645036' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select * from admin.TEST_TFY;

-- 分割线
Select object_name from sys.dba_objects where owner = 'PUBLIC' and object_name = 'QUEST_COM_TEAM_CODING' and object_type = 'SYNONYM' ;

-- 分割线
explain plan set statement_id='1648543649013' for select line||':'||position||':'||text as message from sys.all_errors where type = 'TABLE' and owner = :1 and name = :2 order by sequence;

-- 分割线
select col.*, com.Comments
from sys.all_tab_columns col,
     sys.all_col_comments com
where col.owner = 'SYS'
and col.table_name = 'V_$ARCHIVE_DEST_STATUS'
and com.Owner (+) = 'SYS'
and com.Table_Name (+) = 'V_$ARCHIVE_DEST_STATUS'
and com.Column_Name (+) = col.Column_Name
order by col.column_id
;

-- 分割线
explain plan set statement_id='1648457228194' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  * from table(dbms_xplan.display_cursor('as0bnz42tpyuf'));

-- 分割线
explain plan set statement_id='1641717060620' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '9bv0v66azy2as' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646637413950' for SELECT COUNT('x') FROM SYS.ALL_TABLES WHERE OWNER IN ('TOAD', USER) AND TABLE_NAME IN ('CX_XPERTRUN', 'CX_XPERTLINES', 'CX_XPERTITEMS', 'CX_TYPES', 'CX_SEVERITYS', 'CX_SETRULES', 'CX_RULESETS', 'CX_METRICS', 'CX_METRICRANGES', 'CX_CATEGORYS', 'CX_BASERULES');

-- 分割线
explain plan set statement_id='1641453075235' for select * from table(dbms_xplan.display_cursor('a9yp2pbzx7hy2'));

-- 分割线
explain plan set statement_id='1645777867164' for SELECT /* OPT_DYN_SAMP */ /*+ ALL_ROWS IGNORE_WHERE_CLAUSE NO_PARALLEL(SAMPLESUB) opt_param('parallel_execution_enabled', 'false') NO_PARALLEL_INDEX(SAMPLESUB) NO_SQL_TUNE */ NVL(SUM(C1),0), NVL(SUM(C2),0) FROM (SELECT /*+ IGNORE_WHERE_CLAUSE NO_PARALLEL("PLAN_TABLE") FULL("PLAN_TABLE") NO_PARALLEL_INDEX("PLAN_TABLE") */ 1 AS C1, CASE WHEN "PLAN_TABLE"."STATEMENT_ID"=:1  THEN 1 ELSE 0 END AS C2 FROM "SYS"."PLAN_TABLE$" "PLAN_TABLE") SAMPLESUB;

-- 分割线
explain plan set statement_id='1640934694406' for select * from table(dbms_xplan.display_cursor('416w8vpr6tq9v'));

-- 分割线
explain plan set statement_id='1628737275286' for SELECT V.VIEW_NAME, V.OWNER, (SELECT STATUS FROM SYS.ALL_OBJECTS WHERE OWNER = V.OWNER AND OBJECT_NAME = V.VIEW_NAME AND OBJECT_TYPE = 'VIEW' AND SUBOBJECT_NAME IS NULL) STATUS FROM SYS.ALL_VIEWS V WHERE V.OWNER = 'TEST' ORDER BY V.OWNER, V.VIEW_NAME ASC;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('88krwmynj5s85'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('0zq07n9y15cz2'));

-- 分割线
explain plan set statement_id='1641453079615' for select * from table(dbms_xplan.display_cursor('6kxm4k8uznf7n'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TEST_1';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'SESSION_ROLES' AND OWNER='SYS';

-- 分割线
/*NDTM*/ SELECT DISTINCT s.owner, s.object_name, s.object_type, s.INST_ID, s.mb, s.sql_id, dbms_lob.substr(s.sql_text,3600) sql_text, s.count_table_scan FROM ( WITH detail AS ( SELECT wsp.object_owner owner, wsp.object_name, wsp.object_type, TO_CHAR(TRUNC(ds.bytes / 1024 / 1024, 2)) mb, wsp.sql_id, ws.sql_text, dhs.INSTANCE_NUMBER AS INST_ID FROM sys.WRH$_SQL_PLAN wsp, dba_hist_snapshot dhs, v$instance vi, dba_segments ds, sys.wrh$_sqltext ws WHERE wsp.SNAP_ID = dhs.SNAP_ID AND wsp.dbid = dhs.dbid AND dhs.INSTANCE_NUMBER = vi.INSTANCE_NUMBER AND wsp.object_owner = ds.owner AND wsp.object_name = ds.segment_name AND wsp.object_type = ds.segment_type AND ws.snap_id = wsp.SNAP_ID AND ws.sql_id = wsp.sql_id AND ws.dbid = wsp.dbid AND wsp.OPERATION = 'TABLE ACCESS' AND wsp.options = 'FULL' AND ds.owner NOT IN ('SYS', 'SYSTEM') AND ds.segment_type IN ('TABLE', 'TABLE PARTITION') AND dhs.BEGIN_INTERVAL_TIME > SYSDATE - 1 ) SELECT owner, object_name, object_type, mb, sql_id, sql_text, 'null' count_table_scan, INST_ID FROM detail WHERE ( mb > 50) OR ( sql_id IN ( SELECT d.sql_id FROM detail d GROUP BY d.sql_id HAVING COUNT(1) > 10 ) ) ) s;

-- 分割线
explain plan set statement_id='1641803446429' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '6fhwn94t9ujcu' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TABLES' AND OWNER='TEST';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='2a1m18vrcmmay'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1648543648846' for SELECT TIMESTAMP,ID,LPAD(' ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_HASH_VALUE AS PLAN_ID FROM V$SQL_PLAN WHERE SQL_ID = :1 AND PLAN_HASH_VALUE = :2 AND HASH_VALUE = :3 ORDER BY TIMESTAMP,id;

-- 分割线
explain plan set statement_id='1640934731545' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '84crq17m8xs07' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646731688700' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ALL_TABLES' AND OWNER='SYS';

-- 分割线
EXPLAIN PLAN FOR select
 INDEX_NAME objectName,
 OWNER objectOwner,
 num_rows tablerows,
 last_analyzed updateTime
from
 dba_indexes
where
 TABLE_NAME = 'TEST_TFY'
 AND OWNER = 'ADMIN';

-- 分割线
explain plan set statement_id='1641453078610' for select * from table(dbms_xplan.display_cursor('3vv8cbn9wgfqw'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('3f4qvfh3n1sk3'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'byv94a4v9gr3u' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DUAL' AND OWNER='SYS';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_EXTERNAL_TABLES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641285063295' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='g3f3cw3zy5aat'and is_obsolete = 'N' and child_number =0;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1640934695786' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2cwb7bzq4xs47' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '5wp4sdhqmmdnz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646702436496' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641521235616' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1646702439978' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$DATAGUARD_STATS' AND OWNER='TESTUSERM';

-- 分割线
select owner , table_name  from dba_tables where TABLESPACE_NAME not in ('SYSTEM','SYSAUX') and rownum < 3000;

-- 分割线
explain plan set statement_id='1640856672119' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7z6wnb12pqacz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('ccczh528wha7w'));

-- 分割线
explain plan set statement_id='1641285062886' for select * from table(dbms_xplan.display_cursor('ad02wkjhnxbj0'));

-- 分割线
explain plan set statement_id='1641371382658' for select * from table(dbms_xplan.display_cursor('6qt0wkdatpcsb'));

-- 分割线
explain plan set statement_id='1642056083854' for select * from table(dbms_xplan.display_cursor('87rvzr13t7gdc'));

-- 分割线
explain plan set statement_id='1641971530906' for select * from table(dbms_xplan.display_cursor('6g8fzkd5szxnz'));

-- 分割线
/*NDTM*/ SELECT * FROM( SELECT B.OWNER, B.TABLE_NAME, B.SEGMENT_NAME, B.TABLESPACE_NAME, H.INSERTS + H.UPDATES + H.DELETES AS H_SUM , H.INSERTS, H.UPDATES, H.DELETES FROM ( SELECT T.OWNER, T.TABLE_NAME, T.TABLESPACE_NAME, T.NUM_ROWS, NVL(T.CLUSTER_NAME, T.TABLE_NAME) AS SEGMENT_NAME , T.PARTITIONED, T.MONITORING FROM sys.DBA_TABLES T WHERE OWNER NOT IN ( 'DBSNMP', 'SYSMAN', 'FLOWS_FILES', 'MDSYS', 'ORDSYS', 'EXFSYS', 'WMSYS', 'APPQOSSYS', 'APEX_030200', 'OWBSYS_AUDIT', 'ORDDATA', 'CTXSYS', 'ANONYMOUS', 'XDB', 'ORDPLUGINS', 'OWBSYS', 'SI_INFORMTN_SCHEMA', 'OLAPSYS', 'MGMT_VIEW', 'SYS', 'SYSTEM', 'OUTLN') ) B, ( SELECT table_name, SUM(INSERTs) AS INSERTs, SUM(updates) AS updates, SUM(deletes) AS deletes FROM sys.dba_tab_modifications GROUP BY table_name ) H WHERE B.TABLE_NAME = H.TABLE_NAME ORDER BY H_SUM DESC ) WHERE rownum <= 30;

-- 分割线
explain plan set statement_id='1642056088521' for select * from table(dbms_xplan.display_cursor('a1tgpg3y1mj2x'));

-- 分割线
SELECT COUNT(*) AS COUNT FROM ( 
select * from T1 )  TT;

-- 分割线
/*NDTM*/SELECT R.NAME,S.SID SID,S.SERIAL# SERIAL, S.SCHEMANAME,S.MACHINE,T.XID,T.START_TIME,T.STATUS,G.RSSIZE RSSIZE , T.NOUNDO NOUNDO,G.EXTENTS EXTENTS,SUBSTR(S.PROGRAM, 1, 50) PROGRAM FROM V$SESSION S, V$TRANSACTION T, V$ROLLNAME R,V$ROLLSTAT G WHERE T.ADDR = S.TADDR AND T.XIDUSN = R.USN AND R.USN = G.USN ORDER BY T.USED_UBLK DESC;

-- 分割线
explain plan set statement_id='1646702438257' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1641453079133' for select * from table(dbms_xplan.display_cursor('88krwmynj5s85'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('00z3ntw951vps'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('cs81gzwtyq4n6'));

-- 分割线
explain plan set statement_id='1641453079433' for select * from table(dbms_xplan.display_cursor('18dbvrqp92ahp'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1640934695418' for select * from table(dbms_xplan.display_cursor('f0a1c90fu7jtd'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_EXTERNAL_TABLES' AND OWNER='SYS';

-- 分割线
select sys_context('userenv', 'current_schema') from dual
;

-- 分割线
explain plan set statement_id='1641883289210' for select * from table(dbms_xplan.display_cursor('bfkda1khvgbab'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('9am4sfvrsw1jb'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('9n0wrh7g1sytk'));

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'd8f51h9xk6drw' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('d9wuz6ba3v5x6'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4x8k7c993s3kk'));

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='5a4nkjgphcrg5'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('1kcq1g5hs0rq1'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='ADMIN';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select null from all_synonyms where 1=0
;

-- 分割线
explain plan set statement_id='1640853021005' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ extractvalue(xmlval, '/*/info[@type = "sql_profile"]'), extractvalue(xmlval, '/*/info[@type = "sql_patch"]'), extractvalue(xmlval, '/*/info[@type = "baseline"]'), extractvalue(xmlval, '/*/info[@type = "outline"]'), extractvalue(xmlval, '/*/info[@type = "dynamic_sampling"]'), extractvalue(xmlval, '/*/info[@type = "dop"]'), extractvalue(xmlval, '/*/info[@type = "dop_reason"]'), extractvalue(xmlval, '/*/info[@type = "queuing_reason"]'), extractvalue(xmlval, '/*/info[@type = "row_shipping"]'), extractvalue(xmlval, '/*/info[@type = "index_size"]'), extractvalue(xmlval, '/*/info[@type = "result_checksum"]'), extractvalue(xmlval, '/*/info[@type = "cardinality_feedback"]'), extractvalue(xmlval, '/*/info[@type = "xml_suboptimal"]'), extractvalue(xmlval,'/*/info[@type = "plan_hash"]') from (select xmltype(:1  ) xmlval from dual);

-- 分割线
/*NDTM*/ select q2.other_tname ts_name, nvl(total_free,0) totalfree, nvl(round((total_free/ts_size)*100,2),0) pct_free from (select dfs.tablespace_name,count(*) pieces,round(max(dfs.bytes)/1024/1024,2) largest_chunk,round(sum(dfs.bytes)/1024/1024,2) total_free from dba_free_space dfs group by tablespace_name) q1,(select tablespace_name other_tname, round(sum(ddf2.bytes)/1024/1024,2) ts_size from dba_data_files ddf2 group by tablespace_name) q2 where q2.other_tname = q1.tablespace_name(+) and tablespace_name in (select tablespace_name from dba_tablespaces where contents='PERMANENT') and nvl(round((total_free/ts_size)*100,2),0) < 15;

-- 分割线
explain plan set statement_id='1641285062269' for select * from table(dbms_xplan.display_cursor('1u8u45tqp2s8r'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('92rvs66bzpxpr'));

-- 分割线
explain plan set statement_id='1641889864699' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641971521438' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2pyxt8v955cpr' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
Select 'USER' object_type, null owner, username object_name
from sys.DBA_USERS
where username = :obj
union all
Select 'TABLESPACE' object_type, null owner, tablespace_name object_name
from sys.DBA_TABLESPACES
where tablespace_name = :obj
union all
Select 'PROFILE' object_type, null owner, profile object_name
from sys.dba_profiles
where profile = :obj
and rownum = 1
union all
Select 'FLASHBACK ARCHIVE' object_type, OWNER_NAME owner, FLASHBACK_ARCHIVE_NAME object_name
from dba_flashback_archive
where flashback_archive_name = :obj
union all
Select 'ROLE' object_type, null owner, role object_name
from sys.dba_roles
where role = :obj;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1648543646426' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641971529613' for select * from table(dbms_xplan.display_cursor('c9v8s44gf19ta'));

-- 分割线
explain plan set statement_id='1640766682907' for select * from v$archived_log;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST' AND OWNER='ADMIN';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641717056038' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='ADMIN';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('gj89hnjp4nz3y'));

-- 分割线
explain plan set statement_id='1645777886596' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$PARAMETER' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1648517493435' for select line||':'||position||':'||text as message from sys.all_errors where type = 'TABLE' and owner = :1 and name = :2 order by sequence;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'NLS_SESSION_PARAMETERS' AND OWNER='TESTUSERM';

-- 分割线
SELECT VALUE FROM V$PARAMETER WHERE NAME = 'cluster_database';

-- 分割线
 select DEST_ID, STATUS, DESTINATION, ERROR from V$ARCHIVE_DEST where DEST_ID<=3
;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select   dest_id, dest_name, status,database_mode,recovery_mode ,protection_mode ,
destination  ,standby_logfile_count, standby_logfile_active,archived_seq#  ,applied_seq# ,error    ,
 synchronization_status,  gap_status   from v$archive_dest_status where rownum <4
;

-- 分割线
declare
  in_owner varchar2(128) := null;
  in_name varchar2(128) := null;
  in_column varchar2(128) := null;
  xyzzy SYS_REFCURSOR;
begin
  in_owner := :1 ;
  in_name := :2 ;
  in_column := :3 ;
open xyzzy for
SELECT NULL AS table_cat,
       t.owner AS table_schem,
       t.table_name AS table_name,
       t.column_name AS column_name,
DECODE(  (SELECT a.typecode 
     FROM ALL_TYPES A 
     WHERE a.type_name = t.data_type), 
  'OBJECT', 2002, 
  'COLLECTION', 2003, 
  DECODE(substr(t.data_type, 1, 9), 
    'TIMESTAMP', 
      DECODE(substr(t.data_type, 10, 1), 
        '(', 
          DECODE(substr(t.data_type, 19, 5), 
            'LOCAL', -102, 'TIME ', -101, 93), 
        DECODE(substr(t.data_type, 16, 5), 
          'LOCAL', -102, 'TIME ', -101, 93)), 
    'INTERVAL ', 
      DECODE(substr(t.data_type, 10, 3), 
       'DAY', -104, 'YEA', -103), 
    DECODE(t.data_type, 
      'BINARY_DOUBLE', 101, 
      'BINARY_FLOAT', 100, 
      'BFILE', -13, 
      'BLOB', 2004, 
      'CHAR', 1, 
      'CLOB', 2005, 
      'COLLECTION', 2003, 
      'DATE', 93, 
      'FLOAT', 6, 
      'LONG', -1, 
      'LONG RAW', -4, 
      'NCHAR', -15, 
      'NCLOB', 2011, 
      'NUMBER', 2, 
      'NVARCHAR', -9, 
      'NVARCHAR2', -9, 
      'OBJECT', 2002, 
      'OPAQUE/XMLTYPE', 2009, 
      'RAW', -3, 
      'REF', 2006, 
      'ROWID', -8, 
      'SQLXML', 2009, 
      'UROWID', -8, 
      'VARCHAR2', 12, 
      'VARRAY', 2003, 
      'XMLTYPE', 2009, 
      1111)))
 AS data_type,
       t.data_type AS type_name,
       DECODE (t.data_precision,                null, DECODE(t.data_type,                        'NUMBER', DECODE(t.data_scale,                                    null, 0                                   , 38),        DECODE (t.data_type,                'CHAR', t.char_length,                'VARCHAR', t.char_length,                'VARCHAR2', t.char_length,                'NVARCHAR2', t.char_length,                'NCHAR', t.char_length,                'NUMBER', 0,                t.data_length)                           ),         t.data_precision)
              AS column_size,
       0 AS buffer_length,
       DECODE (t.data_type,                'NUMBER', DECODE(t.data_precision,                                 null, DECODE(t.data_scale,                                              null, -127                                             , t.data_scale),                                  t.data_scale),                t.data_scale) AS decimal_digits,
       10 AS num_prec_radix,
       DECODE (t.nullable, 'N', 0, 1) AS nullable,
       NULL AS remarks,
       t.data_default AS column_def,
       0 AS sql_data_type,
       0 AS sql_datetime_sub,
       t.data_length AS char_octet_length,
       t.column_id AS ordinal_position,
       DECODE (t.nullable, 'N', 'NO', 'YES') AS is_nullable,
       null as SCOPE_CATALOG,
       null as SCOPE_SCHEMA,
       null as SCOPE_TABLE,
       null as SOURCE_DATA_TYPE,
       'NO' as IS_AUTOINCREMENT,
       null as IS_GENERATEDCOLUMN
FROM all_tab_columns t
WHERE t.owner LIKE in_owner ESCAPE '/'
  AND t.table_name LIKE in_name ESCAPE '/'
  AND t.column_name LIKE in_column ESCAPE '/'
ORDER BY table_schem, table_name, ordinal_position
; 
 :4  := xyzzy;
 end;;

-- 分割线
explain plan set statement_id='1640856681076' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '034j8nxagtz7x' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641453075156' for select * from table(dbms_xplan.display_cursor('5q9nbbpn3gjs3'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'PLAN_TABLE$' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('66r41s9493sdd'));

-- 分割线
SELECT *
FROM v$parameter
WHERE name = 'cluster_database'
	AND ROWNUM <= 200;

-- 分割线
explain plan set statement_id='1641453078668' for select * from table(dbms_xplan.display_cursor('bv7kbhp83f6tn'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5gwxh6rwzdnyh'));

-- 分割线
explain plan set statement_id='1646637407067' for select object_name from sys.all_procedures where owner = 'RDSADMIN' and object_name = 'RDSADMIN_UTIL' and object_type = 'PACKAGE' and subprogram_id = 0;

-- 分割线
explain plan set statement_id='1641883275744' for select * from table(dbms_xplan.display_cursor('0z16b9a7jg1fd'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641453079889' for select * from table(dbms_xplan.display_cursor('ac2s4nwbnq3pc'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'c3c0ugvm3qp4w' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('fgvsn1yq6su67'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-16', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1645777892744' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '0x7wdrznxxb2x' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
SELECT ET.TABLE_NAME EXT_TABLE_NAME, T.TABLE_NAME, T.IOT_TYPE FROM SYS.ALL_ALL_TABLES T, SYS.ALL_EXTERNAL_TABLES ET, SYS.ALL_TAB_COMMENTS TC WHERE T.IOT_NAME IS NULL AND T.NESTED = 'NO' AND T.SECONDARY = 'N' AND NOT EXISTS (SELECT 1 FROM SYS.ALL_MVIEWS MV WHERE MV.OWNER = T.OWNER AND MV.MVIEW_NAME = T.TABLE_NAME) AND TC.OWNER(+) = T.OWNER AND TC.TABLE_NAME(+) = T.TABLE_NAME AND ET.TABLE_NAME(+) = T.TABLE_NAME AND ET.OWNER(+) = T.OWNER AND T.OWNER = 'TEST' ORDER BY T.TABLE_NAME ASC;

-- 分割线
explain plan set statement_id='1640853003661' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641885101247' for select * from table(dbms_xplan.display_cursor('958dh0014w3g2'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$PARAMETER' AND OWNER='TEST';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1640140550476' for DELETE FROM TEST.TABLE_EXPLAIN1 WHERE C1=3;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7kywm7ss6rsn3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7y1accaf2gs2n' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1640856671022' for select * from table(dbms_xplan.display_cursor('f3bdf51bf4kdm'));

-- 分割线
explain plan set statement_id='1640856671492' for select * from table(dbms_xplan.display_cursor('6nhq8j4938xvs'));

-- 分割线
explain plan set statement_id='1641803443822' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'fywzhtdzap6a1' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
Select SYS_CONTEXT('USERENV', 'IDENTIFICATION_TYPE') from dual;

-- 分割线
explain plan set statement_id='1641803448956' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7gh1p0p74vbmd' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1646036979513' for SELECT SQL_ID, PLAN_HASH_VALUE, HASH_VALUE FROM V$SQL_PLAN;

-- 分割线
explain plan set statement_id='1641803445198' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '9218gv43t56yt' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1640766681987' for select * from v$thread;

-- 分割线
explain plan set statement_id='1641544224554' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'T1' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2f4n9f18uba5v'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('3vv8cbn9wgfqw'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1641889872401' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641285061776' for select * from table(dbms_xplan.display_cursor('g3f3cw3zy5aat'));

-- 分割线
explain plan set statement_id='1641803451448' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '0fpcqvxtpjg8y' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='04aa4upv3asqu'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1641803447764' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7qpdwc27pjj3t' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641883289237' for select * from table(dbms_xplan.display_cursor('8x2qvbxjkptd1'));

-- 分割线
explain plan set statement_id='1641453074849' for select * from table(dbms_xplan.display_cursor('as0bnz42tpyuf'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('0yakq5gw37sd5'));

-- 分割线
explain plan set statement_id='1640853003863' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('db44tvvh79yyz'));

-- 分割线
explain plan set statement_id='1641544226418' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1640934724871' for select * from table(dbms_xplan.display_cursor('asf38z37wp4qv'));

-- 分割线
explain plan set statement_id='1641885079646' for select * from table(dbms_xplan.display_cursor('0dunju3vkd444'));

-- 分割线
explain plan set statement_id='1642056082417' for select * from table(dbms_xplan.display_cursor('4zxwtuujk1bsa'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('8gftjrxn16apj'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-09', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-09', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-09', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('4ksy7br58ztqh'));

-- 分割线
Select owner from sys.dba_objects where object_name = 'QU_VERSION' and object_type in ('PACKAGE','SYNONYM') and rownum = 1;

-- 分割线
explain plan set statement_id='1641371373919' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  * from table(dbms_xplan.display_cursor('cdc6vtv1t5p9s'));

-- 分割线
explain plan set statement_id='1641521231562' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1648543648300' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log order by  2,3,4;

-- 分割线
Select 1 from sys.dba_objects where object_type = 'TABLE' and object_name = 'SQLNAV_PROGRAM_STATUS_LOG';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'SESSION_ROLES' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('7bsjfwurah7yd'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('dkz9hbzbtykk5'));

-- 分割线
explain plan set statement_id='1640852999506' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('6s1wpny5b309n'));

-- 分割线
explain plan set statement_id='1642056082760' for select * from table(dbms_xplan.display_cursor('ddtyj7madmut2'));

-- 分割线
explain plan set statement_id='1648543649249' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641544234296' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='ADMIN';

-- 分割线
begin dbms_output.get_line(line => :line, status => :status); end;;

-- 分割线
select  * from table(dbms_xplan.display_cursor('d8f51h9xk6drw'));

-- 分割线
explain plan set statement_id='1641883292310' for select * from table(dbms_xplan.display_cursor('6b1n01pnmanbt'));

-- 分割线
SELECT *
FROM v$parameter
WHERE name = 'cluster_database_instances'
	AND ROWNUM <= 200;

-- 分割线
explain plan set statement_id='1641889879454' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T' AND OWNER='ADMIN';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='null'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1641717059046' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '47tms0z7bu01c' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('g0ws1f49b0a27'));

-- 分割线
/*NDTM*/SELECT A.SNAP_ID AS SNAP_ID, TO_CHAR(B.end_interval_time, 'yyyy-mm-dd hh24:mi:ss') AS end_interval_time , A.INSTANCE_NUMBER, A.STAT_NAME, A.VALUE FROM ( SELECT SNAP_ID, INSTANCE_NUMBER, 'pins' AS STAT_NAME, SUM(pins) AS VALUE FROM DBA_HIST_LIBRARYCACHE GROUP BY SNAP_ID, INSTANCE_NUMBER UNION ALL SELECT SNAP_ID, INSTANCE_NUMBER, 'pinhits' AS STAT_NAME, SUM(pinhits) AS VALUE FROM DBA_HIST_LIBRARYCACHE GROUP BY SNAP_ID, INSTANCE_NUMBER UNION ALL SELECT SNAP_ID, INSTANCE_NUMBER, 'misses' AS STAT_NAME, SUM(misses) AS VALUE FROM DBA_HIST_LATCH GROUP BY SNAP_ID, INSTANCE_NUMBER UNION ALL SELECT SNAP_ID, INSTANCE_NUMBER, 'gets' AS STAT_NAME, SUM(gets) AS VALUE FROM DBA_HIST_LATCH GROUP BY SNAP_ID, INSTANCE_NUMBER UNION ALL SELECT SNAP_ID, INSTANCE_NUMBER, 'wait_count' AS STAT_NAME, SUM(WAIT_COUNT) AS VALUE FROM DBA_HIST_WAITSTAT GROUP BY SNAP_ID, INSTANCE_NUMBER UNION ALL SELECT SNAP_ID, INSTANCE_NUMBER, STAT_NAME, VALUE FROM DBA_HIST_SYSSTAT WHERE STAT_NAME IN ('session logical reads', 'physical reads', 'physical reads direct', 'physical reads direct (lob)', 'consistent gets from cache', 'db block gets', 'parse count (total)', 'execute count', 'parse time cpu', 'parse time elapsed', 'redo log space requests', 'redo entries', 'sorts (disk)', 'sorts (memory)', 'parse count (total)', 'parse count (hard)', 'CPU used by this session', 'parse time cpu', 'user commits', 'user rollbacks', 'execute count', 'user call', 'DB time') ) A, ( SELECT SNAP_ID, instance_number, end_interval_time FROM dba_hist_snapshot WHERE SNAP_ID = ( SELECT MAX(SNAP_ID) FROM dba_hist_snapshot) AND ( CURRENT_DATE-interval '2' hour)<end_interval_time) B WHERE A.SNAP_ID= B.SNAP_ID AND A.INSTANCE_NUMBER=B.INSTANCE_NUMBER;

-- 分割线
explain plan set statement_id='1648457198626' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1640856679229' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '84crq17m8xs07' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST1';

-- 分割线
insert into TEST_TFY values(1,'aa');

-- 分割线
select   dest_id, dest_name, status,database_mode,recovery_mode ,protection_mode ,
destination  ,standby_logfile_count, standby_logfile_active,archived_seq#  ,applied_seq# ,error    ,
 synchronization_status,  gap_status   from v$archive_dest_status
;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST_1';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'PLAN_TABLE$' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('3930b9ks77xcm'));

-- 分割线
explain plan set statement_id='1642056086021' for select * from table(dbms_xplan.display_cursor('ddtyj7madmut2'));

-- 分割线
explain plan set statement_id='1641889868641' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1641285066233' for select * from table(dbms_xplan.display_cursor('ah6u6jcfqzzx2'));

-- 分割线
explain plan set statement_id='1641453078749' for select * from table(dbms_xplan.display_cursor('as870xurrmqfs'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('749x052ct6chf'));

-- 分割线
explain plan set statement_id='1641717054896' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'PLAN_TABLE$' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641885097669' for select * from table(dbms_xplan.display_cursor('g2qcfq151ff34'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-14', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641717055356' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2hgkdp40cgt7f'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('0d92tkqsdysj3'));

-- 分割线
explain plan set statement_id='1640934729303' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '034j8nxagtz7x' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='ADMIN';

-- 分割线
select * from TEST.TABLE_EXPLAIN1;

-- 分割线
explain plan set statement_id='1640856674696' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2cwb7bzq4xs47' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641521229923' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1648457226159' for SELECT TIMESTAMP,ID,LPAD(' ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_HASH_VALUE AS PLAN_ID FROM V$SQL_PLAN WHERE SQL_ID = :1 AND PLAN_HASH_VALUE = :2 AND HASH_VALUE = :3 ORDER BY TIMESTAMP,id;

-- 分割线
explain plan set statement_id='1646702436793' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TABLES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641885094963' for select * from table(dbms_xplan.display_cursor('7gmhqhhbb5bak'));

-- 分割线
explain plan set statement_id='1642056088734' for select * from table(dbms_xplan.display_cursor('264kw741ar4xa'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$PARAMETER' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1642056082844' for select * from table(dbms_xplan.display_cursor('f5ftc21vzjcs1'));

-- 分割线
explain plan set statement_id='1645777891068' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='bwpx4sbms18bu'and is_obsolete = 'N' and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('034j8nxagtz7x'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$DATAGUARD_STATS' AND OWNER='TESTUSERM';

-- 分割线
select sys_context('USERENV','INSTANCE_NAME'), sys_context('USERENV','SERVER_HOST') from dual;

-- 分割线
explain plan set statement_id='1641883275617' for select * from table(dbms_xplan.display_cursor('958dh0014w3g2'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('3q35t7yn505n5'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('7uzttn0rx0ggr'));

-- 分割线
SELECT  NULL AS table_cat,
       t.owner AS table_schem,
       t.table_name AS table_name,
       t.column_name AS column_name,
       DECODE (t.data_type, 'CHAR', 1, 'VARCHAR2', 12, 'NUMBER', 3,
               'LONG', -1, 'DATE', 93, 'RAW', -3, 'LONG RAW', -4,  
               'BLOB', 2004, 'CLOB', 2005, 'BFILE', -13, 'FLOAT', 6, 
               'TIMESTAMP(6)', 93, 'TIMESTAMP(6) WITH TIME ZONE', -101, 
               'TIMESTAMP(6) WITH LOCAL TIME ZONE', -102, 
               'INTERVAL YEAR(2) TO MONTH', -103, 
               'INTERVAL DAY(2) TO SECOND(6)', -104, 
               'BINARY_FLOAT', 100, 'BINARY_DOUBLE', 101, 
               1111)
              AS data_type,
       t.data_type AS type_name,
       DECODE (t.data_precision, null,          DECODE (t.data_type, 'CHAR', t.char_length,                   'VARCHAR', t.char_length,                   'VARCHAR2', t.char_length,                   'NVARCHAR2', t.char_length,                   'NCHAR', t.char_length,           t.data_length),         t.data_precision)
              AS column_size,
       0 AS buffer_length,
       t.data_scale AS decimal_digits,
       10 AS num_prec_radix,
       DECODE (t.nullable, 'N', 0, 1) AS nullable,
       NULL AS remarks,
       t.data_default AS column_def,
       0 AS sql_data_type,
       0 AS sql_datetime_sub,
       t.data_length AS char_octet_length,
       t.column_id AS ordinal_position,
       DECODE (t.nullable, 'N', 'NO', 'YES') AS is_nullable
FROM all_tab_columns t
WHERE t.owner LIKE :1 ESCAPE '/'
  AND t.table_name LIKE :2 ESCAPE '/'
  AND t.column_name LIKE :3 ESCAPE '/'

ORDER BY table_schem, table_name, ordinal_position
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('49ww0cvch2b6w'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1641453079725' for select * from table(dbms_xplan.display_cursor('3q35t7yn505n5'));

-- 分割线
/*NDTM*/select * from dba_tab_privs where TABLE_NAME not  in (SELECT OBJECT_NAME FROM DBA_RECYCLEBIN WHERE TYPE='TABLE') and OWNER NOT IN ('ANONYMOUS', 'CTXSYS', 'DBSNMP', 'EXFSYS', 'LBACSYS', 'MDSYS', 'MGMT_VIEW', 'OLAPSYS', 'ORDDATA', 'OWBSYS', 'ORDPLUGINS', 'ORDSYS', 'OUTLN', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'WK_TEST', 'WKSYS', 'WKPROXY', 'WMSYS', 'XDB', 'ASMSNMP', 'APEX_PUBLIC_USER', 'DIP', 'FLOWS_040100', 'FLOWS_FILES', 'MDDATA', 'ORACLE_OCM', 'SPATIAL_CSW_ADMIN_USR', 'SPATIAL_WFS_ADMIN_USR', 'XS$NULL', 'BI', 'HR', 'OE', 'PM', 'IX', 'SH', 'SCOTT', 'APPQOSSYS', 'APEX_030200', 'OWBSYS_AUDIT','HIS') and GRANTEE not in ('PUBLIC');

-- 分割线
select  * from table(dbms_xplan.display_cursor('cq5vxj2xsrmn5'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('6jvbv8mhctra4'));

-- 分割线
explain plan set statement_id='1640853002061' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1642056083997' for select * from table(dbms_xplan.display_cursor('2f4n9f18uba5v'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('c10vdnb4s3mzb'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'USER$' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('ddtyj7madmut2'));

-- 分割线
explain plan set statement_id='1641717059573' for select * from table(dbms_xplan.display_cursor('80z99jfgvbg6a'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('8yw3zu6ahvbc3'));

-- 分割线
begin :id := sys.dbms_transaction.local_transaction_id; end;
;

-- 分割线
SELECT *
FROM v$database
WHERE ROWNUM <= 200;

-- 分割线
explain plan set statement_id='1642056085802' for select * from table(dbms_xplan.display_cursor('5r3gskq6wjfyt'));

-- 分割线
explain plan set statement_id='1641717057886' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1641803452704' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '9h8u76wpgcgzz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641453078783' for select * from table(dbms_xplan.display_cursor('2hk3q9vty2sh6'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'B' AND OWNER='TEST1';

-- 分割线
CALL DBMS_OUTPUT.ENABLE();

-- 分割线
explain plan set statement_id='1641521235998' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST1' AND OWNER='TEST_1';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1642056082870' for select * from table(dbms_xplan.display_cursor('00z3ntw951vps'));

-- 分割线
explain plan set statement_id='1641453075264' for select * from table(dbms_xplan.display_cursor('6kxm4k8uznf7n'));

-- 分割线
explain plan set statement_id='1648543645716' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1642056089661' for select * from table(dbms_xplan.display_cursor('53tath0qc36p2'));

-- 分割线
explain plan set statement_id='1640852999946' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线

select db_link as object_name, 'DATABASE LINK' as object_type
  from sys.all_db_links o
  where o.owner = :schema
     or o.owner = 'PUBLIC'
;

-- 分割线
explain plan set statement_id='1640853002619' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TESTUSERM';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-14', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641889868276' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST1';

-- 分割线
select  * from (select sequence#,count(*) num from  v$archived_log  group by sequence#) where num >1;

-- 分割线
/*NDTM*/ SELECT * FROM ( SELECT t.owner, t.table_name, s.segment_type, NVL(t.tablespace_name, ' ') AS tablespace_name, t.segment_name, s.total_size, s.max_partition_size, s.min_partition_size, s.avg_partition_size, t.num_rows, t.partitioned, t.monitoring, s.partitionednum FROM ( SELECT OWNER, TABLE_NAME, TABLESPACE_NAME, PARTITIONED, MONITORING, NVL(CLUSTER_NAME, TABLE_NAME) SEGMENT_NAME, NUM_ROWS FROM DBA_TABLES WHERE OWNER NOT IN ('ANONYMOUS', 'CTXSYS', 'DBSNMP', 'EXFSYS', 'LBACSYS', 'MDSYS', 'MGMT_VIEW', 'OLAPSYS', 'ORDDATA', 'OWBSYS', 'ORDPLUGINS', 'ORDSYS', 'OUTLN', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'WK_TEST', 'WKSYS', 'WKPROXY', 'WMSYS', 'XDB', 'ASMSNMP', 'APEX_PUBLIC_USER', 'DIP', 'FLOWS_040100', 'FLOWS_FILES', 'MDDATA', 'ORACLE_OCM', 'SPATIAL_CSW_ADMIN_USR', 'SPATIAL_WFS_ADMIN_USR', 'XS$NULL', 'BI', 'HR', 'OE', 'PM', 'IX', 'SH', 'SCOTT', 'APPQOSSYS', 'APEX_030200', 'OWBSYS_AUDIT', 'HIS')) t, ( SELECT segment_name, segment_type, owner, SUM(bytes) / 1024 / 1024 total_size, AVG(bytes) / 1024 / 1024 avg_partition_size, MAX(bytes) / 1024 / 1024 max_partition_size, MIN(bytes) / 1024 / 1024 min_partition_size, COUNT(1) AS PARTITIONEDNUM FROM dba_segments WHERE segment_type IN ('TABLE', 'TABLE SUBPARTITION', 'TABLE PARTITION') GROUP BY segment_name, owner , segment_type) s WHERE t.table_name = s.segment_name AND t.owner = s.owner ORDER BY total_size DESC) WHERE rownum <= 100;

-- 分割线
select  * from table(dbms_xplan.display_cursor('gt2yvn9ny6wdf'));

-- 分割线
explain plan set statement_id='1641453079376' for select * from table(dbms_xplan.display_cursor('6p1un7ryqtgr6'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('dj0vzkumjbavu'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T1' AND OWNER='TEST';

-- 分割线
SELECT version, product, sysdate FROM sys.PRODUCT_COMPONENT_VERSION WHERE UPPER(PRODUCT) LIKE '%ORACLE%';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select object_name from sys.all_procedures where owner = 'RDSADMIN' and object_name = 'RDSADMIN_UTIL' and object_type = 'PACKAGE' and subprogram_id = 0;

-- 分割线
explain plan set statement_id='1646731690915' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_MVIEWS' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2tktr2ckzq2x4'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1641889864516' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641544232581' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641453079212' for select * from table(dbms_xplan.display_cursor('c6cbwvdw329bs'));

-- 分割线
select null from dba_synonyms where 1=0
;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-14', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-14', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-14', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('6p1un7ryqtgr6'));

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1640766682600' for select nvl(to_char(max(completion_time),'YYYY-MM-DD hh24:mi:ss'),'NULL') stb_max_completion_time, nvl(to_char(sysdate - 24/24,'YYYY-MM-DD hh24:mi:ss'),'NULL') stb_delete_time, ceil(max(completion_time) - (sysdate - 24/24)) stb_time_minus from v$archived_log where applied='YES' and deleted='NO';

-- 分割线
select  * from table(dbms_xplan.display_cursor('5a4nkjgphcrg5'));

-- 分割线
explain plan set statement_id='1646637406788' for SELECT u.NAME FROM sys.USER$ u WHERE u.TYPE# = 1 ORDER BY 1;

-- 分割线
explain plan set statement_id='1646731690966' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TESTUSERM';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_MVIEWS' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('22x8t0a3dccy4'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('d1mvpn59qs3ds'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('35qfcrhtfa7ky'));

-- 分割线
explain plan set statement_id='1641544224260' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$PARAMETER' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641544225996' for SELECT /* OPT_DYN_SAMP */ /*+ ALL_ROWS IGNORE_WHERE_CLAUSE NO_PARALLEL(SAMPLESUB) opt_param('parallel_execution_enabled', 'false') NO_PARALLEL_INDEX(SAMPLESUB) NO_SQL_TUNE */ NVL(SUM(C1),:"SYS_B_0"), NVL(SUM(C2),:"SYS_B_1") FROM (SELECT /*+ NO_PARALLEL("PLAN_TABLE") FULL("PLAN_TABLE") NO_PARALLEL_INDEX("PLAN_TABLE") */ :"SYS_B_2" AS C1, :"SYS_B_3" AS C2 FROM "SYS"."PLAN_TABLE$" "PLAN_TABLE") SAMPLESUB;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-17', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('8vh13jzta9rrj'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('fsw8111ja9wbd'));

-- 分割线
explain plan set statement_id='1642056082818' for select * from table(dbms_xplan.display_cursor('5gmfdfuu8s3y9'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('18dbvrqp92ahp'));

-- 分割线
SELECT  TIMESTAMP,ID,LPAD('  ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_HASH_VALUE AS PLAN_ID FROM V$SQL_PLAN WHERE SQL_ID = :1  AND PLAN_HASH_VALUE = :2  AND HASH_VALUE = :3  ORDER BY TIMESTAMP,id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='ADMIN';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641883291571' for select * from table(dbms_xplan.display_cursor('958dh0014w3g2'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('fyjgn1shxgp93'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/ select sequence_owner,sequence_name,CEIL((LAST_NUMBER-MIN_VALUE)/(MAX_VALUE-MIN_VALUE)*100) SequencePctUsed from dba_sequences where CYCLE_FLAG='N' and INCREMENT_BY > 0 and sequence_owner in (select username from dba_users where account_status='OPEN' and username not in ('APEX_030200','SCOTT','ANONYMOUS','CTXSYS','DBSNMP','EXFSYS','LBACSYS','MDSYS','MGMT_VIEW','OLAPSYS','ORDDATA','OWBSYS','ORDPLUGINS','ORDSYS','OUTLN','SI_INFORMTN_SCHEMA','SYS','SYSMAN','SYSTEM','WK_TEST','WKSYS','WKPROXY','WMSYS','XDB','APEX_PUBLIC_USER','DIP','FLOWS_040100','FLOWS_FILES','MDDATA','ORACLE_OCM','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','XS\','BI','HR','OE','PM','IX','SH','DMSYS','OWBSYS_AUDIT','TSMSYS','APPQOSSYS','PATROL','SYS','SYSTEM')) and CEIL((LAST_NUMBER-MIN_VALUE)/(MAX_VALUE-MIN_VALUE)*100) >= 70 union all select sequence_owner,sequence_name,CEIL((MAX_VALUE-LAST_NUMBER)/(MAX_VALUE-MIN_VALUE)*100) SequencePctUsed from dba_sequences where CYCLE_FLAG='N' and INCREMENT_BY < 0 and sequence_owner in (select username from dba_users where account_status='OPEN' and username not in ('APEX_030200','SCOTT','ANONYMOUS','CTXSYS','DBSNMP','EXFSYS','LBACSYS','MDSYS','MGMT_VIEW','OLAPSYS','ORDDATA','OWBSYS','ORDPLUGINS','ORDSYS','OUTLN','SI_INFORMTN_SCHEMA','SYS','SYSMAN','SYSTEM','WK_TEST','WKSYS','WKPROXY','WMSYS','XDB','APEX_PUBLIC_USER','DIP','FLOWS_040100','FLOWS_FILES','MDDATA','ORACLE_OCM','SPATIAL_CSW_ADMIN_USR','SPATIAL_WFS_ADMIN_USR','XS\','BI','HR','OE','PM','IX','SH','DMSYS','OWBSYS_AUDIT','TSMSYS','APPQOSSYS','PATROL','SYS','SYSTEM')) and CEIL((MAX_VALUE-LAST_NUMBER)/(MAX_VALUE-MIN_VALUE)*100) >= 70;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1640853003283' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='TESTUSERM';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641971521038' for select * from table(dbms_xplan.display_cursor('bwfqugv98w67g'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2qay7rz6nxy7h' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select   dest_id, dest_name, status,database_mode,recovery_mode ,protection_mode ,
destination  ,standby_logfile_count, standby_logfile_active,archived_seq#  ,applied_seq# ,error    ,
 synchronization_status,  gap_status   from v$archive_dest_status where rownum <3
;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$ARCHIVED_LOG' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('9q0tdutcnvcd5'));

-- 分割线
explain plan set statement_id='1641453079241' for select * from table(dbms_xplan.display_cursor('7j011s5pbj837'));

-- 分割线
explain plan set statement_id='1646731687414' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T1' AND OWNER='TEST1';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('5zn6pm8jmh2b6'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5ctkrx7wpcx7t'));

-- 分割线
SELECT u.NAME
FROM sys.USER$ u
WHERE u.TYPE# = 1
ORDER BY 1;

-- 分割线
explain plan set statement_id='1646731692175' for select value from v$sesstat where sid = :1  order by statistic#;

-- 分割线
select  * from table(dbms_xplan.display_cursor('53tath0qc36p2'));

-- 分割线
explain plan set statement_id='1641285066471' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='3nyjqy5vzxup6'and is_obsolete = 'N' and child_number =0;

-- 分割线
Select   'X'
  FROM   DBA_OBJECTS
 WHERE   object_name = :name AND object_type = :TYPE AND owner = :owner;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-15', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641883293787' for select * from table(dbms_xplan.display_cursor('2wtud18rngt6z'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('18m629uzyj2fu'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_MVIEWS' AND OWNER='TEST';

-- 分割线
select length(chr(2000000000)) l4, length(chr(2000000)) l3,  length(chr(20000)) l2, 'c' c1 from dual
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('7gmhqhhbb5bak'));

-- 分割线
explain plan set statement_id='1641285062011' for select * from table(dbms_xplan.display_cursor('6dhqk6msdmgq7'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SESSTAT' AND OWNER='DBMON';

-- 分割线
select  * from table(dbms_xplan.display_cursor('2yf14a1kv8xqk'));

-- 分割线
explain plan set statement_id='1645691396470' for select * from test_tfy;

-- 分割线
explain plan set statement_id='1645691396362' for SELECT COUNT(*) AS COUNT FROM ( select * from TEST_TFY ) TT;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TESTUSERM';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TABLES' AND OWNER='SYS';

-- 分割线
select  * from table(dbms_xplan.display_cursor('03zh5148c7cpj'));

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'gt2yvn9ny6wdf' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TT' AND OWNER='ADMIN';

-- 分割线
SELECT COUNT(*) AS COUNT FROM ( 
select * from B )  TT;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DUAL' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641521231375' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1646731692091' for SELECT * FROM V$ARCHIVE_DEST;

-- 分割线
explain plan set statement_id='1641453079402' for select * from table(dbms_xplan.display_cursor('5q9nbbpn3gjs3'));

-- 分割线
explain plan set statement_id='1648543649364' for select line||':'||position||':'||text as message from sys.all_errors where type = 'TABLE' and owner = :1 and name = :2 order by sequence;

-- 分割线
explain plan set statement_id='1640934734584' for select * from table(dbms_xplan.display_cursor('avc8w4usc40zg'));

-- 分割线
explain plan set statement_id='1642056086047' for select * from table(dbms_xplan.display_cursor('d1mvpn59qs3ds'));

-- 分割线
explain plan set statement_id='1641971521343' for select * from table(dbms_xplan.display_cursor('9hfaxykuqr8f0'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('fxttrw4q8u4sv'));

-- 分割线
explain plan set statement_id='1641521235840' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST' AND OWNER='TEST_1';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_TABLES' AND OWNER='TESTUSERM';

-- 分割线
declare  cursor NlsParamsCursor is    SELECT * FROM nls_session_parameters;begin  SELECT Nvl(Lengthb(Chr(16777216)), Nvl(Lengthb(Chr(65536)), Nvl(Lengthb(Chr(256)), 1))), Nvl(Lengthb(Chr(1)), 1)    INTO :MaxCharLength, :MinCharLength FROM dual;  for NlsRecord in NlsParamsCursor loop    if NlsRecord.parameter = 'NLS_DATE_LANGUAGE' then      :NlsDateLanguage := NlsRecord.value;    elsif NlsRecord.parameter = 'NLS_DATE_FORMAT' then      :NlsDateFormat := NlsRecord.value;    elsif NlsRecord.parameter = 'NLS_NUMERIC_CHARACTERS' then      :NlsNumericCharacters := NlsRecord.value;    elsif NlsRecord.parameter = 'NLS_TIMESTAMP_FORMAT' then      :NlsTimeStampFormat := NlsRecord.value;    elsif NlsRecord.parameter = 'NLS_TIMESTAMP_TZ_FORMAT' then      :NlsTimeStampTZFormat := NlsRecord.value;    end if;  end loop;end;;

-- 分割线
explain plan set statement_id='1646731691859' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TT' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1640766682110' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from v$archived_log where sequence#=27833;

-- 分割线
explain plan set statement_id='1640934695526' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7z6wnb12pqacz' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641976262322' for select * from table(dbms_xplan.display_cursor('9pkmrq6atj0ub'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('2hk3q9vty2sh6'));

-- 分割线
explain plan set statement_id='1642056083972' for select * from table(dbms_xplan.display_cursor('4x8k7c993s3kk'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('86whujztyz13b'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-22', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('null'));

-- 分割线
explain plan set statement_id='1641883293762' for select * from table(dbms_xplan.display_cursor('0z16b9a7jg1fd'));

-- 分割线
explain plan set statement_id='1648543649472' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
SELECT * FROM (
    SELECT t.*
    FROM TEST.CCC t
) WHERE ROWNUM <= 501;

-- 分割线
select  * from table(dbms_xplan.display_cursor('4882s0h26pd5v'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-13', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-20', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select  * from table(dbms_xplan.display_cursor('a7h8jrusuwga4'));

-- 分割线
explain plan set statement_id='1641976272095' for select * from table(dbms_xplan.display_cursor('90fnm4t6vya2s'));

-- 分割线
explain plan set statement_id='1640140550476' for SELECT COUNT(*)  FROM TEST.TABLE_EXPLAIN1 WHERE C1=3;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('9rvd8qx86gz36'));

-- 分割线
explain plan set statement_id='1646637405919' for select dbms_utility.current_instance from dual;

-- 分割线
explain plan set statement_id='1641453074780' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='8vh13jzta9rrj'and is_obsolete = 'N' and child_number =0;

-- 分割线
EXPLAIN PLAN FOR select
 *
from
 TEST_TFY;

-- 分割线
explain plan set statement_id='1641971521000' for select * from table(dbms_xplan.display_cursor('7hz1mwfjs8j5w'));

-- 分割线
select DBID from v$database;

-- 分割线
SELECT SQL_ID, PLAN_HASH_VALUE, HASH_VALUE FROM V$SQL_PLAN;

-- 分割线
select lengthb(nchr(20)), nchr(20) from dual
;

-- 分割线
explain plan set statement_id='1646731691159' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TEST123' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641889870817' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T1' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1641803441342' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '91p2qpv992z9g' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1640853013279' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'byv94a4v9gr3u' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('6r4at74u1rah4'));

-- 分割线
explain plan set statement_id='1641285064610' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='70w2qtpvh2y10'and is_obsolete = 'N' and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('98b1jfj2rr541'));

-- 分割线
select * from TEST_TFY;

-- 分割线
select  * from table(dbms_xplan.display_cursor('1r50gw95cxrkd'));

-- 分割线
explain plan set statement_id='1640766681799' for select name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from v$archived_log where completion_time > sysdate - 2 order by 2,3,4;

-- 分割线
explain plan set statement_id='1641717059549' for select * from table(dbms_xplan.display_cursor('98aanjk82zt4v'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('daafstj3sg4p5'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1646731688797' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_OBJECTS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641889879843' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'gt2yvn9ny6wdf' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select object_name nam, Decode(object_type, 'TABLE', 1, 'VIEW', 2, 3) typ
from   sys.user_objects
where  object_type in ('TABLE','PROCEDURE', 'PACKAGE', 'FUNCTION');

-- 分割线
explain plan set statement_id='1641285064224' for select * from table(dbms_xplan.display_cursor('g914mamrdszq7'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('bfkda1khvgbab'));

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count,creator from  v$archived_log  where deleted='NO' and completion_time > sysdate - 2 order by  2,3,4;

-- 分割线
explain plan set statement_id='1641285062300' for select * from table(dbms_xplan.display_cursor('fqf3d15yfvzxz'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('6dxf5jwa4yt4z'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='ADMIN';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'TT' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641885100073' for select * from table(dbms_xplan.display_cursor('1mqh79fdzhf70'));

-- 分割线
select (owner || '@@@@@' ||  table_name) as dd  from dba_tables where TABLESPACE_NAME not in ('SYSTEM','SYSAUX') and rownum < 3000;

-- 分割线
explain plan set statement_id='1641889878150' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641453079323' for select * from table(dbms_xplan.display_cursor('f6cgh73251q7u'));

-- 分割线
explain plan set statement_id='1641883275758' for select * from table(dbms_xplan.display_cursor('2wtud18rngt6z'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('amsgdax010aw8'));

-- 分割线
explain plan set statement_id='1641971521358' for select * from table(dbms_xplan.display_cursor('2pyxt8v955cpr'));

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log  where sequence#=27851;

-- 分割线
select name from v$statname order by statistic#
;

-- 分割线
select SYS_CONTEXT('USERENV','SID') from dual;

-- 分割线
select  * from table(dbms_xplan.display_cursor('1mqh79fdzhf70'));

-- 分割线
explain plan set statement_id='1641453075170' for select * from table(dbms_xplan.display_cursor('18dbvrqp92ahp'));

-- 分割线
explain plan set statement_id='1645777887866' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '2rudykata7b7n' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('2ga7m2vfu3m04'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1641971521262' for select * from table(dbms_xplan.display_cursor('frbbbtxfqgjcb'));

-- 分割线
Select  last_ddl_time
  FROM sys.DBA_OBJECTS
 WHERE object_type = :type AND owner = :owner AND object_name = :name;

-- 分割线
explain plan set statement_id='1641285065863' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='42su53424c8yy'and is_obsolete = 'N' and child_number =0;

-- 分割线
explain plan set statement_id='1641971532199' for select * from table(dbms_xplan.display_cursor('80mdbf96kxzpp'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4r5px7hgt2h43'));

-- 分割线
explain plan set statement_id='1640853003762' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TESTUSERM';

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-08', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1642056082499' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddtyj7madmut2' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('57ncubd7r0dja'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-24', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-24', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-24', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'user commits' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST1';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SESSTAT' AND OWNER='DBMON';

-- 分割线
explain plan set statement_id='1641885100048' for select * from table(dbms_xplan.display_cursor('0dunju3vkd444'));

-- 分割线
explain plan set statement_id='1645691396308' for SELECT COUNT(*) AS COUNT FROM ( select * from TEST_TFY ) TT;

-- 分割线
select  * from table(dbms_xplan.display_cursor('fth9t8yspfn8x'));

-- 分割线
select 'x' from dual
;

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'bx7tcw6zm75b3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_MVIEWS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1648517491752' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TYPES' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641717059804' for select * from table(dbms_xplan.display_cursor('f0mxa0uj34gpw'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST1';

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_VIEWS' AND OWNER='SYS';

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                       /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null,
                        null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ 
                          vp.id id, vp.depth depth, vp.position position, 
                          vp.operation operation, vp.options options,
                          vp.cost cost, vp.time time, 
                          vp.cardinality cardinality, vp.bytes bytes, 
                          vp.object_node object_node,
                          vp.object_name object_name, vp.other_tag other_tag, 
                          vp.partition_start partition_start,
                          vp.partition_stop partition_stop, 
                          vp.distribution distribution, 
                          vp.temp_space temp_space, vp.io_cost io_cost,
                          vp.cpu_cost cpu_cost, 
                          vp.filter_predicates filter_predicates, 
                          vp.access_predicates access_predicates, 
                          vp.other other, vp.projection projection, 
                          vp.qblock_name qblock_name, 
                          vp.object_alias object_alias, 
                          vp.other_xml other_xml, 
                          v$sql.sql_profile sql_profile, 
                          v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets,
                                     0 reads,
                                     0 writes, 0 etime,
                                     0 mem_opt,
                                     0 mem_one,
                                     null last_mem_used,
                                     null last_mem_usage,
                                     0 opt_cnt,
                                     0 one_cnt,
                                     0 multi_cnt,
                                     0 max_tmp,
                                     0 last_tmp
               from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '034j8nxagtz7x' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='5wp4sdhqmmdnz'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1641976267102' for select * from table(dbms_xplan.display_cursor('4zuhqffm960m3'));

-- 分割线
explain plan set statement_id='1645691396076' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641544225657' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'PLAN_TABLE' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1645777888460' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '754ns9zs3ywgd' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641544225802' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL_PLAN' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641717060376' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_TABLES' AND OWNER='TEST_1';

-- 分割线
explain plan set statement_id='1641885096508' for select * from table(dbms_xplan.display_cursor('1r50gw95cxrkd'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('264kw741ar4xa'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('bv6664dgbb9cg'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('astnk0fv428x9'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TABLES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641971521019' for select * from table(dbms_xplan.display_cursor('53xavd3t6q9vz'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$ARCHIVE_DEST' AND OWNER='DBMON';

-- 分割线
SELECT /* OPT_DYN_SAMP */ /*+ ALL_ROWS IGNORE_WHERE_CLAUSE NO_PARALLEL(SAMPLESUB) opt_param('parallel_execution_enabled', 'false') NO_PARALLEL_INDEX(SAMPLESUB) NO_SQL_TUNE */ NVL(SUM(C1),:"SYS_B_0"), NVL(SUM(C2),:"SYS_B_1") FROM (SELECT /*+ NO_PARALLEL("PLAN_TABLE") FULL("PLAN_TABLE") NO_PARALLEL_INDEX("PLAN_TABLE") */ :"SYS_B_2" AS C1, :"SYS_B_3" AS C2 FROM "SYS"."PLAN_TABLE$" "PLAN_TABLE") SAMPLESUB;

-- 分割线
select  * from table(dbms_xplan.display_cursor('bvhghpg1ykmgq'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'CCC' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('btgkqja0hxgut'));

-- 分割线
explain plan set statement_id='1641889873906' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST1';

-- 分割线
explain plan set statement_id='1640140555332' for MERGE INTO TEST.TABLE_EXPLAIN1 t1 USING TEST.TABLE_EXPLAIN2 t2 ON (t1.c1 = t2.c1) WHEN MATCHED THEN UPDATE SET t1.c2 = t2.c2;

-- 分割线
select  * from table(dbms_xplan.display_cursor('bs183pgg9uz09'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641803455149' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '4arv915z1t1zg' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
/*NDTM*//*NDTM*/with pgastat as (
select to_char(b.begin_interval_time,'yyyymmdd_hh24mi')                                snaptime
      ,round(sum(decode(a.name,'total PGA inuse',a.value,0))/1024/1024)                pga_inuse
      ,round(sum(decode(a.name,'total PGA allocated',a.value,0))/1024/1024)            pga_alloc
      ,round(sum(decode(a.name,'maximum PGA allocated',a.value,0))/1024/1024)          max_alloc
      ,sum(decode(a.name,'process count',a.value,0))                                   proc_cnt
      ,sum(decode(a.name,'max processes count',a.value,0))                             max_proc_cnt
      ,round(sum(decode(a.name,'aggregate PGA target parameter',a.value,0))/1024/1024) pga_target
      ,round(sum(decode(a.name,'aggregate PGA auto target',a.value,0))/1024/1024)      auto_target
      ,sum(decode(a.name,'over allocation count',a.value,0))                           over_cnt
      ,round(sum(decode(a.name,'bytes processed',a.value,0))/1024/1024)                proc_mb
      ,round(sum(decode(a.name,'extra bytes read/written',a.value,0))/1024/1024)       extra_mb
      ,round(sum(decode(a.name,'cache hit percentage',a.value,0)))                     hitratio
from   dba_hist_pgastat  a,
       dba_hist_snapshot b
where a.dbid=b.dbid
and   a.snap_id=b.snap_id
and   a.instance_number=b.instance_number
and   a.instance_number=(select instance_number from v$instance)
and   a.name in
      ('total PGA inuse'
      ,'total PGA allocated'
      ,'maximum PGA allocated'
      ,'process count'
      ,'max processes count'
      ,'aggregate PGA target parameter'
      ,'aggregate PGA auto target'
      ,'over allocation count'
      ,'bytes processed'
      ,'extra bytes read/written'
      ,'cache hit percentage')
--and   b.begin_interval_time >= trunc(sysdate-&v_days)
group by to_char(b.begin_interval_time,'yyyymmdd_hh24mi')
order by 1)
select snaptime
      ,pga_inuse
      ,pga_alloc
      ,max_alloc
      ,pga_target
      ,auto_target
      ,proc_cnt
      ,max_proc_cnt
      ,proc_mb
      ,over_cnt
      ,hitratio,
      count(1) over() as num_count
from (select snaptime
            ,pga_inuse
            ,pga_alloc
            ,max_alloc
            ,pga_target
            ,auto_target
            ,proc_cnt
            ,max_proc_cnt
            ,proc_mb-lag(proc_mb) over (order by snaptime)   proc_mb
            ,extra_mb-lag(extra_mb) over (order by snaptime) extra_mb
            ,over_cnt-lag(over_cnt) over (order by snaptime) over_cnt
            ,hitratio
            ,rank () over (order by snaptime) ranking
      from pgastat)
where ranking >1
order by snaptime;

-- 分割线
select  * from table(dbms_xplan.display_cursor('f86ng805zdqt8'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DUAL' AND OWNER='DBMON';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='4081gvsw832v2'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1641521233974' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1641521232014' for SELECT TIMESTAMP,ID,LPAD(' ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_ID FROM PLAN_TABLE WHERE STATEMENT_ID = :1  ORDER BY TIMESTAMP,id;

-- 分割线
explain plan set statement_id='1640934721591' for select * from table(dbms_xplan.display_cursor('7ky7nb27tb187'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.INSTANCE_NAME,
	data_date,
	data_hour,
	round(sum( delta ) / 1024 / 1024 / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 100,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour  
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total bytes', 'physical write total bytes' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$SQL' AND OWNER='ADMIN';

-- 分割线
select  * from table(dbms_xplan.display_cursor('175vv32dxn226'));

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-10', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-21', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641885079494' for select * from table(dbms_xplan.display_cursor('6jvbv8mhctra4'));

-- 分割线
explain plan set statement_id='1641521236208' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'TEST' AND OWNER='TEST_1';

-- 分割线
select  * from table(dbms_xplan.display_cursor('gzw2hqtuxbab1'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('4vc1p3v8bkapg'));

-- 分割线
begin sys.dbms_application_info.set_module('PL/SQL Developer', :action); end;
;

-- 分割线
select  * from table(dbms_xplan.display_cursor('anmxr6jwthpmc'));

-- 分割线
explain plan set statement_id='1641453074908' for select * from table(dbms_xplan.display_cursor('0d92tkqsdysj3'));

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TESTUSERM';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='byv94a4v9gr3u'and is_obsolete = 'N'  and child_number =0;

-- 分割线
explain plan set statement_id='1641889864347' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COLUMNS' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1642056082774' for select * from table(dbms_xplan.display_cursor('d1mvpn59qs3ds'));

-- 分割线
explain plan set statement_id='1642056085827' for select * from table(dbms_xplan.display_cursor('bjgn6qh7krsjg'));

-- 分割线
explain plan set statement_id='1641717061127' for select * from table(dbms_xplan.display_cursor('2hbxgcnbs78yz'));

-- 分割线
explain plan set statement_id='1642056082313' for select * from table(dbms_xplan.display_cursor('fyjgn1shxgp93'));

-- 分割线
explain plan set statement_id='1641285065051' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='ad02wkjhnxbj0'and is_obsolete = 'N' and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('81ww6gxg67stk'));

-- 分割线
SELECT *  FROM ( SELECT TT.*,ROWNUM  RN FROM ( 
select * from T1 ) TT WHERE ROWNUM < = 05 ) WHERE RN > 0;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-13', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) p,
		(
		SELECT
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER,
			sum( a.VALUE ) AS value 
		FROM
			sys.WRH$_SYS_TIME_MODEL a,
			( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'background cpu time', 'DB CPU' ) ) b,
			sys.dba_hist_snapshot snap 
		WHERE
			a.STAT_ID = b.STAT_ID 
			AND a.snap_id = snap.SNAP_ID ( + ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-13', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		GROUP BY
			a.DBID,
			a.SNAP_ID,
			a.INSTANCE_NUMBER 
		ORDER BY
			SNAP_ID DESC 
		) n,
		sys.dba_hist_snapshot snap 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-13', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1645691377911' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
explain plan set statement_id='1640853013155' for select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='2a1m18vrcmmay'and is_obsolete = 'N' and child_number =0;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'T' AND OWNER='TEST';

-- 分割线
explain plan set statement_id='1641544232987' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = 'ddrx31kvkt7bg' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
/*NDTM*/SELECT C.OWNER, C.OBJECT_NAME, C.SUBOBJECT_NAME, C.OBJECT_ID, C.DATA_OBJECT_ID, C.OBJECT_TYPE, to_char(C.CREATED, 'yyyy-mm-dd hh24:mi:ss') AS CREATED, to_char(C.LAST_DDL_TIME, 'yyyy-mm-dd hh24:mi:ss') AS LAST_DDL_TIME, C.TIMESTAMP, C.STATUS, C.TEMPORARY, C.GENERATED, C.SECONDARY, C.NAMESPACE, C.EDITION_NAME FROM DBA_INVALID_OBJECTS C WHERE STATUS = 'INVALID' union all SELECT A.OWNER, A.OBJECT_NAME, A.SUBOBJECT_NAME, A.OBJECT_ID, A.DATA_OBJECT_ID, A.OBJECT_TYPE, to_char(A.CREATED, 'yyyy-mm-dd hh24:mi:ss') AS CREATED, to_char(A.LAST_DDL_TIME, 'yyyy-mm-dd hh24:mi:ss') AS LAST_DDL_TIME, A.TIMESTAMP, B.STATUS, A.TEMPORARY, A.GENERATED, A.SECONDARY, A.NAMESPACE, A.EDITION_NAME FROM DBA_OBJECTS A,DBA_INDEXES B WHERE A.OWNER=B.OWNER AND A.OBJECT_NAME=B.INDEX_NAME AND A.OBJECT_TYPE='INDEX' AND B.STATUS = 'UNUSABLE';

-- 分割线
/*NDTM*/SELECT
	stat_name,
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / ( ( SELECT cpu_count_current FROM v$license ) * 3600 ) ,5) AS delta
FROM
	(
	SELECT
		n.dbid AS dbid,
		nm.stat_name,
		n.instance_number,
		round( ( n.value - nvl( p.value, 0 ) ) / 1000000, 3 ) AS delta,
		to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
		to_char( snap.begin_interval_time, 'hh24' ) AS data_hour,
		snap.begin_interval_time 
	FROM
		sys.wrh$_sys_time_model p,
		sys.wrh$_sys_time_model n,
		sys.wrh$_stat_name nm,
		sys.dba_hist_snapshot snap,
		GV$INSTANCE g 
	WHERE
		n.dbid = p.dbid ( + ) 
		AND n.instance_number = p.instance_number ( + ) 
		AND n.snap_id - 1 = p.snap_id ( + ) 
		AND n.stat_id = p.stat_id ( + ) 
		AND n.stat_id = nm.stat_id 
		AND n.dbid = nm.dbid 
		AND P.snap_id = snap.SNAP_ID ( + ) 
		AND n.value > nvl( p.value, 0 ) 
		AND nm.stat_name = 'DB time' 
		AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-22', 'yyyy-mm-dd' ) 
		AND snap.begin_interval_time IS NOT NULL 
	ORDER BY
		P.SNAP_ID DESC 
	) t,
	GV$INSTANCE g 
WHERE
	data_date IS NOT NULL 
	AND t.instance_number = g.inst_id 
GROUP BY
	data_date,
	data_hour,
	stat_name,
	g.instance_name,
	dbid 
ORDER BY
	data_date DESC;

-- 分割线
begin sys.dbms_application_info.set_module('TOAD background query session', null); end;;

-- 分割线
BEGIN
  SYS.DBMS_APPLICATION_INFO.SET_MODULE('TOAD 12.0.0.61', null);
END;;

-- 分割线
select dbms_utility.current_instance from dual;

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-26', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641544224029' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'PLAN_TABLE' AND OWNER='TEST';

-- 分割线
select  * from table(dbms_xplan.display_cursor('byv94a4v9gr3u'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TEST';

-- 分割线

select * from B;

-- 分割线
explain plan set statement_id='1641521229579' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$SQL' AND OWNER='TESTUSERM';

-- 分割线
select  * from table(dbms_xplan.display_cursor('f5ftc21vzjcs1'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'ALL_TYPES' AND OWNER='ADMIN';

-- 分割线
explain plan set statement_id='1641885096531' for select * from table(dbms_xplan.display_cursor('d9wuz6ba3v5x6'));

-- 分割线
explain plan set statement_id='1641453074924' for select * from table(dbms_xplan.display_cursor('fth9t8yspfn8x'));

-- 分割线
explain plan set statement_id='1641453074877' for select * from table(dbms_xplan.display_cursor('2hk3q9vty2sh6'));

-- 分割线
explain plan set statement_id='1645777884723' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'DUAL' AND OWNER='ADMIN';

-- 分割线
BEGIN DBMS_OUTPUT.ENABLE(buffer_size => NULL); END;;

-- 分割线
explain plan set statement_id='1641717061909' for select * from table(dbms_xplan.display_cursor('axcjntm7jqhh5'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('0bsxvrxsa5wqy'));

-- 分割线
Select sum(decode(object_name, 'DBMS_JAVA', 1, 0)) jv,       sum(decode(object_name, 'DBMS_DEBUG', 1, 0)) dbg from sys.dba_objects where owner = 'SYS' and object_type = 'PACKAGE' and object_name in ('DBMS_JAVA', 'DBMS_DEBUG');

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ALL_TABLES' AND OWNER='SYS';

-- 分割线
explain plan set statement_id='1641971520790' for select * from table(dbms_xplan.display_cursor('a1t3kzfb4jasv'));

-- 分割线
select col.*, com.Comments
from sys.all_tab_columns col,
     sys.all_col_comments com
where col.owner = 'SYS'
and col.table_name = 'V_$ARCHIVE_DEST'
and com.Owner (+) = 'SYS'
and com.Table_Name (+) = 'V_$ARCHIVE_DEST'
and com.Column_Name (+) = col.Column_Name
order by col.column_id
;

-- 分割线
select sys.dbms_transaction.local_transaction_id from dual;

-- 分割线
select comments from sys.all_tab_comments
 where owner      = :object_owner
   and table_name = :object_name
;

-- 分割线
explain plan set statement_id='1646731687495' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_TAB_COMMENTS' AND OWNER='SYS';

-- 分割线
SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ extractvalue(xmlval, '/*/info[@type = "sql_profile"]'), extractvalue(xmlval, '/*/info[@type = "sql_patch"]'), extractvalue(xmlval, '/*/info[@type = "baseline"]'), extractvalue(xmlval, '/*/info[@type = "outline"]'), extractvalue(xmlval, '/*/info[@type = "dynamic_sampling"]'), extractvalue(xmlval, '/*/info[@type = "dop"]'), extractvalue(xmlval, '/*/info[@type = "dop_reason"]'), extractvalue(xmlval, '/*/info[@type = "queuing_reason"]'), extractvalue(xmlval, '/*/info[@type = "row_shipping"]'), extractvalue(xmlval, '/*/info[@type = "index_size"]'), extractvalue(xmlval, '/*/info[@type = "result_checksum"]'), extractvalue(xmlval, '/*/info[@type = "cardinality_feedback"]'), extractvalue(xmlval, '/*/info[@type = "xml_suboptimal"]'), extractvalue(xmlval,'/*/info[@type = "plan_hash"]') from (select xmltype(:v_other_xml) xmlval from dual);

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
				
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		),5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			( n.value - nvl( p.value, 0 ) ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date,
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT DISTINCT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				a.VALUE AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'execute count' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-28', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641285062235' for select * from table(dbms_xplan.display_cursor('7skyjpg0760aa'));

-- 分割线
explain plan set statement_id='1646637404611' for select sys_context('USERENV','INSTANCE_NAME'), sys_context('USERENV','SERVER_HOST') from dual;

-- 分割线
explain plan set statement_id='1641453079271' for select * from table(dbms_xplan.display_cursor('anmxr6jwthpmc'));

-- 分割线
SELECT T.TABLE_NAME, T.OWNER, T.TABLESPACE_NAME, T.CLUSTER_NAME, T.IOT_NAME, T.PCT_FREE, T.PCT_USED, T.INI_TRANS, T.MAX_TRANS, T.INITIAL_EXTENT, T.NEXT_EXTENT, T.MIN_EXTENTS, T.MAX_EXTENTS, T.PCT_INCREASE, T.FREELISTS, T.FREELIST_GROUPS, T.LOGGING, T.BACKED_UP, T.NUM_ROWS, T.BLOCKS, T.EMPTY_BLOCKS, T.AVG_SPACE, T.CHAIN_CNT, T.AVG_ROW_LEN, T.AVG_SPACE_FREELIST_BLOCKS, T.NUM_FREELIST_BLOCKS, T.DEGREE, T.INSTANCES, T.CACHE, T.TABLE_LOCK, T.SAMPLE_SIZE, T.LAST_ANALYZED, T.PARTITIONED, T.IOT_TYPE, T.TEMPORARY, T.SECONDARY, T.NESTED, T.BUFFER_POOL, T.MONITORING, T.CLUSTER_OWNER, TC.COMMENTS, T.OBJECT_ID_TYPE, T.TABLE_TYPE_OWNER, T.TABLE_TYPE, T.GLOBAL_STATS, T.USER_STATS, T.DURATION, T.SKIP_CORRUPT, T.ROW_MOVEMENT, ET.TABLE_NAME EXT_TABLE_NAME, T.DEPENDENCIES, T.COMPRESSION, T.DROPPED, T.STATUS DROP_STATUS, T.COMPRESS_FOR, (SELECT STATUS FROM ALL_OBJECTS O WHERE O.OWNER = T.OWNER AND O.OBJECT_NAME = T.TABLE_NAME AND OBJECT_TYPE = 'TABLE') STATUS, (SELECT GENERATED FROM ALL_OBJECTS O WHERE O.OWNER = T.OWNER AND O.OBJECT_NAME = T.TABLE_NAME AND OBJECT_TYPE = 'TABLE') GENERATED FROM SYS.ALL_ALL_TABLES T, SYS.ALL_EXTERNAL_TABLES ET, SYS.ALL_TAB_COMMENTS TC WHERE T.IOT_NAME IS NULL AND T.NESTED = 'NO' AND T.SECONDARY = 'N' AND NOT EXISTS (SELECT 1 FROM SYS.ALL_MVIEWS MV WHERE MV.OWNER = T.OWNER AND MV.MVIEW_NAME = T.TABLE_NAME) AND TC.OWNER(+) = T.OWNER AND TC.TABLE_NAME(+) = T.TABLE_NAME AND ET.TABLE_NAME(+) = T.TABLE_NAME AND ET.OWNER(+) = T.OWNER AND T.OWNER = 'TEST' ORDER BY T.TABLE_NAME ASC;

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'CCC' AND OWNER='TEST';

-- 分割线
/*NDTM*/ select * from(select inst_id as inst_id, owner as owner, object_name as object_name, nvl(subobject_name,'-') as subobject_name, tablespace_name as tablespace_name, object_type as object_type, nvl(logicalreads,0) as logicalreads, nvl(bufferbusywaits,0) as bufferbusywaits, nvl(dbblockchanges,0) as dbblockchanges, nvl(physicalreads,0) as physicalreads, nvl(physicalwrites,0) as physicalwrites, nvl(physicalreadsdirect,0) as physicalreadsdirect, nvl(physicalwritesdirect,0) as physicalwritesdirect, nvl(physicalreadrequests,0) as physicalreadrequests, nvl(physicalwriterequests,0) as physicalwriterequests, nvl(optimizedphysicalreads,0) as optimizedphysicalreads, nvl(optimizedphysicalwrites,0) as optimizedphysicalwrites, nvl(ITLwaits,0) as ITLwaits, nvl(rowlockwaits,0) as rowlockwaits, nvl(spaceused,0) as spaceused, nvl(spaceallocated,0) as spaceallocated, nvl(segmentscans,0) as segmentscans, nvl(gccrblocksreceived,0) as gccrblocksreceived, nvl(gccurrentblocksreceived,0) as gccurrentblocksreceived, nvl(gcbufferbusy,0) as gcbufferbusy from (select s1.inst_id as inst_id, s1.owner as owner, s1.object_name as object_name, s1.subobject_name as subobject_name, s1.tablespace_name as tablespace_name, s1.object_type as object_type, sum(decode(s1.statistic_name,'logical reads',value,0)) as logicalreads, sum(decode(s1.statistic_name,'buffer busy waits',value,0)) as bufferbusywaits, sum(decode(s1.statistic_name,'db block changes',value,0)) as dbblockchanges, sum(decode(s1.statistic_name,'physical reads',value,0)) as physicalreads, sum(decode(s1.statistic_name,'physical writes',value,0)) as physicalwrites, sum(decode(s1.statistic_name,'physical reads direct',value,0)) as physicalreadsdirect, sum(decode(s1.statistic_name,'physical writes direct',value,0)) as physicalwritesdirect, sum(decode(s1.statistic_name,'physical read requests',value,0)) as physicalreadrequests, sum(decode(s1.statistic_name,'physical write requests',value,0)) as physicalwriterequests, sum(decode(s1.statistic_name,'optimized physical reads',value,0)) as optimizedphysicalreads, sum(decode(s1.statistic_name,'optimized physical writes',value,0)) as optimizedphysicalwrites, sum(decode(s1.statistic_name,'ITL waits',value,0)) as ITLwaits, sum(decode(s1.statistic_name,'row lock waits',value,0)) as rowlockwaits, sum(decode(s1.statistic_name,'space used',value,0)) as spaceused, sum(decode(s1.statistic_name,'space allocated',value,0)) as spaceallocated, sum(decode(s1.statistic_name,'segment scans',value,0)) as segmentscans, sum(decode(s1.statistic_name,'gc cr blocks received',value,0)) as gccrblocksreceived, sum(decode(s1.statistic_name,'gc current blocks received',value,0)) as gccurrentblocksreceived, sum(decode(s1.statistic_name,'gc buffer busy',value,0)) as gcbufferbusy from (select * from (select inst_id,owner,object_name,subobject_name,tablespace_name,object_type,statistic_name,value,row_number() over (partition by inst_ID,STATISTIC_NAME order by value desc nulls last) rn from gv$segment_statistics where TS# not in (select TS# from v$tablespace t,dba_temp_files d where t.name=d.TABLESPACE_NAME or t.name='SYSTEM' or t.name='SYSAUX')) where rn <=10) s1 group by inst_id,owner,object_name,subobject_name,tablespace_name,object_type)) where rownum <=1000 ;

-- 分割线
SELECT NVL(LENGTHB(CHR(16777216)), NVL(LENGTHB(CHR(65536)), NVL(LENGTHB(CHR(256)), 1))), NVL(LENGTHB(CHR(1)), 1) FROM DUAL;

-- 分割线
explain plan set statement_id='1641885101590' for select * from table(dbms_xplan.display_cursor('3wphvwq1fsuz4'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5p92qf9fmp88z'));

-- 分割线
explain plan set statement_id='1641889881692' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '9n0wrh7g1sytk' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('7cj4amx055j4r'));

-- 分割线
explain plan set statement_id='1642056082354' for select * from table(dbms_xplan.display_cursor('bx7tcw6zm75b3'));

-- 分割线
explain plan set statement_id='1640934696838' for select * from table(dbms_xplan.display_cursor('84crq17m8xs07'));

-- 分割线
explain plan set statement_id='1641285066657' for select * from table(dbms_xplan.display_cursor('42su53424c8yy'));

-- 分割线
explain plan set statement_id='1646731688025' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'B' AND OWNER='TEST';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='9n0wrh7g1sytk'and is_obsolete = 'N'  and child_number =0;

-- 分割线
Select  TEXT 
from SYS.DBA_SOURCE 
where OWNER=:owner 
and NAME=:name 
and TYPE=:type 
order by LINE;

-- 分割线
explain plan set statement_id='1641717055172' for select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'PLAN_TABLE$' AND OWNER='SYS';

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='7y1accaf2gs2n'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('7ydsphbhu59hm'));

-- 分割线
/*NDTM*/SELECT
	dbid AS oracle_id,
	g.instance_name,
	data_date,
	data_hour,
	round(sum( delta ) / (
		(
		SELECT
		CASE
			WHEN
				snap_interval = to_char( '+00000 01:00:00.0' ) THEN
					1 
					WHEN snap_interval = '+00000 00:15:00.0' THEN
					0.25 
					WHEN snap_interval = '+00000 00:30:00.0' THEN
					0.5 ELSE 1 
				END AS pl 
			FROM
				dba_hist_wr_control 
			) * 3600 
		) / 5000,5) AS delta 
	FROM
		(
		SELECT DISTINCT
			n.dbid AS dbid,
			n.instance_number,
			round( ( n.value - nvl( p.value, 0 ) ), 3 ) AS delta,
			to_char( snap.begin_interval_time, 'yyyy-mm-dd' ) AS data_date, 
			to_char( snap.begin_interval_time, 'hh24' ) AS data_hour
		FROM
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) p,
			(
			SELECT
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER,
				sum( a.VALUE ) AS value 
			FROM
				sys.WRH$_SYSSTAT a,
				( SELECT * FROM sys.WRH$_STAT_NAME bb WHERE bb.STAT_NAME IN ( 'physical read total IO requests', 'physical write total IO requests' ) ) b 
			WHERE
				a.STAT_ID = b.STAT_ID 
			GROUP BY
				a.DBID,
				a.SNAP_ID,
				a.INSTANCE_NUMBER 
			ORDER BY
				SNAP_ID DESC 
			) n,
			sys.dba_hist_snapshot snap 
		WHERE
			n.dbid = p.dbid ( + ) 
			AND n.instance_number = p.instance_number ( + ) 
			AND n.snap_id - 1 = p.snap_id ( + ) 
			AND P.snap_id = snap.SNAP_ID ( + ) 
			AND n.value > nvl( p.value, 0 ) 
			AND to_date(SUBSTR(to_char(snap.begin_interval_time, 'yyyy-mm-dd hh24'), 1, 10), 'yyyy-mm-dd') = to_date('2022-02-23', 'yyyy-mm-dd' ) 
			AND snap.begin_interval_time IS NOT NULL 
		ORDER BY
			P.SNAP_ID DESC 
		) t,
		GV$INSTANCE g 
	WHERE
		data_date IS NOT NULL 
		AND t.instance_number = g.inst_id 
	GROUP BY
		data_date,
		data_hour,
		g.instance_name,
		dbid 
ORDER BY
	data_date DESC;

-- 分割线
explain plan set statement_id='1641971522541' for select * from table(dbms_xplan.display_cursor('80mdbf96kxzpp'));

-- 分割线
explain plan set statement_id='1640934695804' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '034j8nxagtz7x' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
select  * from table(dbms_xplan.display_cursor('242bcjmm25kq0'));

-- 分割线
select line||':'||position||':'||text as message
from sys.all_errors
where type = 'TABLE' 
  and owner = :1  
  and name = :2  
order by sequence 
;

-- 分割线
explain plan set statement_id='1640852999634' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'V$THREAD' AND OWNER='TESTUSERM';

-- 分割线
select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'ALL_ERRORS' AND OWNER='SYS';

-- 分割线
select  name,dest_id,thread#,sequence#,archived,applied,deleted,status,completion_time,backup_count from  v$archived_log  where sequence#=27833;

-- 分割线
select /* EXEC_FROM_DBMS_XPLAN */ case when upper(sql_text) like '%DBMS_XPLAN%' then 0 else 1 end case, SQL_ID, child_number from v$sql where SQL_ID ='0ushr863b7z39'and is_obsolete = 'N'  and child_number =0;

-- 分割线
select  * from table(dbms_xplan.display_cursor('fah0btzv8ypru'));

-- 分割线
select TABLE_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_tables where TABLE_NAME = 'V$ARCHIVE_DEST' AND OWNER='DBMON';

-- 分割线
explain plan set statement_id='1646731688080' for select INDEX_NAME objectName, OWNER objectOwner, num_rows tablerows, last_analyzed updateTime from dba_indexes where TABLE_NAME = 'DBA_INDEXES' AND OWNER='TESTUSERM';

-- 分割线
explain plan set statement_id='1646637405815' for SELECT USER FROM SYS.DUAL;

-- 分割线
select  * from table(dbms_xplan.display_cursor('44m7rkb1qac5h'));

-- 分割线
Select user as owner, object_name, object_type
from sys.user_objects
where object_name = :obj
and object_type not like '%PARTITION%'
union all
Select user as owner, constraint_name as object_name, 'CONSTRAINT' as object_type
from user_constraints
where constraint_name = :obj
order by 3;

-- 分割线
explain plan set statement_id='gKb8xpE1cWN0ByNWfCdF+Q==' for select * from TEST.TABLE_EXPLAIN1;

-- 分割线
explain plan set statement_id='1641453078843' for select * from table(dbms_xplan.display_cursor('0d92tkqsdysj3'));

-- 分割线
explain plan set statement_id='1648537937941' for SELECT NULL AS TABLE_CAT, T.OWNER AS TABLE_SCHEM, T.TABLE_NAME AS TABLE_NAME, T.COLUMN_NAME AS COLUMN_NAME, DECODE( (SELECT A.TYPECODE FROM ALL_TYPES A WHERE A.TYPE_NAME = T.DATA_TYPE), 'OBJECT', 2002, 'COLLECTION', 2003, DECODE(SUBSTR(T.DATA_TYPE, 1, 9), 'TIMESTAMP', DECODE(SUBSTR(T.DATA_TYPE, 10, 1), '(', DECODE(SUBSTR(T.DATA_TYPE, 19, 5), 'LOCAL', -102, 'TIME ', -101, 93), DECODE(SUBSTR(T.DATA_TYPE, 16, 5), 'LOCAL', -102, 'TIME ', -101, 93)), 'INTERVAL ', DECODE(SUBSTR(T.DATA_TYPE, 10, 3), 'DAY', -104, 'YEA', -103), DECODE(T.DATA_TYPE, 'BINARY_DOUBLE', 101, 'BINARY_FLOAT', 100, 'BFILE', -13, 'BLOB', 2004, 'CHAR', 1, 'CLOB', 2005, 'COLLECTION', 2003, 'DATE', 93, 'FLOAT', 6, 'LONG', -1, 'LONG RAW', -4, 'NCHAR', -15, 'NCLOB', 2011, 'NUMBER', 2, 'NVARCHAR', -9, 'NVARCHAR2', -9, 'OBJECT', 2002, 'OPAQUE/XMLTYPE', 2009, 'RAW', -3, 'REF', 2006, 'ROWID', -8, 'SQLXML', 2009, 'UROWID', -8, 'VARCHAR2', 12, 'VARRAY', 2003, 'XMLTYPE', 2009, 1111))) AS DATA_TYPE, T.DATA_TYPE AS TYPE_NAME, DECODE (T.DATA_PRECISION, NULL, DECODE(T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_SCALE, NULL, 0 , 38), DECODE (T.DATA_TYPE, 'CHAR', T.CHAR_LENGTH, 'VARCHAR', T.CHAR_LENGTH, 'VARCHAR2', T.CHAR_LENGTH, 'NVARCHAR2', T.CHAR_LENGTH, 'NCHAR', T.CHAR_LENGTH, 'NUMBER', 0, T.DATA_LENGTH) ), T.DATA_PRECISION) AS COLUMN_SIZE, 0 AS BUFFER_LENGTH, DECODE (T.DATA_TYPE, 'NUMBER', DECODE(T.DATA_PRECISION, NULL, DECODE(T.DATA_SCALE, NULL, -127 , T.DATA_SCALE), T.DATA_SCALE), T.DATA_SCALE) AS DECIMAL_DIGITS, 10 AS NUM_PREC_RADIX, DECODE (T.NULLABLE, 'N', 0, 1) AS NULLABLE, NULL AS REMARKS, T.DATA_DEFAULT AS COLUMN_DEF, 0 AS SQL_DATA_TYPE, 0 AS SQL_DATETIME_SUB, T.DATA_LENGTH AS CHAR_OCTET_LENGTH, T.COLUMN_ID AS ORDINAL_POSITION, DECODE (T.NULLABLE, 'N', 'NO', 'YES') AS IS_NULLABLE, NULL AS SCOPE_CATALOG, NULL AS SCOPE_SCHEMA, NULL AS SCOPE_TABLE, NULL AS SOURCE_DATA_TYPE, 'NO' AS IS_AUTOINCREMENT, NULL AS IS_GENERATEDCOLUMN FROM ALL_TAB_COLUMNS T WHERE T.OWNER LIKE :B3 ESCAPE '/' AND T.TABLE_NAME LIKE :B2 ESCAPE '/' AND T.COLUMN_NAME LIKE :B1 ESCAPE '/' ORDER BY TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;

-- 分割线
select  * from table(dbms_xplan.display_cursor('4zxwtuujk1bsa'));

-- 分割线
explain plan set statement_id='1641544230135' for SELECT /*+ opt_param('parallel_execution_enabled', 'false') */ /* EXEC_FROM_DBMS_XPLAN */ id, position, depth , operation, options, object_name, cardinality, bytes, temp_space, cost, io_cost, cpu_cost, time, partition_start, partition_stop, object_node, other_tag, distribution, null, access_predicates, filter_predicates, other, null, null, other_xml, sql_profile, sql_plan_baseline, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null from (select /*+ no_merge */ vp.id id, vp.depth depth, vp.position position, vp.operation operation, vp.options options, vp.cost cost, vp.time time, vp.cardinality cardinality, vp.bytes bytes, vp.object_node object_node, vp.object_name object_name, vp.other_tag other_tag, vp.partition_start partition_start, vp.partition_stop partition_stop, vp.distribution distribution, vp.temp_space temp_space, vp.io_cost io_cost, vp.cpu_cost cpu_cost, vp.filter_predicates filter_predicates, vp.access_predicates access_predicates, vp.other other, vp.projection projection, vp.qblock_name qblock_name, vp.object_alias object_alias, vp.other_xml other_xml, v$sql.sql_profile sql_profile, v$sql.sql_plan_baseline sql_plan_baseline, 0 starts, 0 outrows, 0 crgets, 0 cugets, 0 reads, 0 writes, 0 etime, 0 mem_opt, 0 mem_one, null last_mem_used, null last_mem_usage, 0 opt_cnt, 0 one_cnt, 0 multi_cnt, 0 max_tmp, 0 last_tmp from V$SQL_PLAN vp, v$sql where vp.SQL_ID = '7kywm7ss6rsn3' and vp.child_number=0 and vp.SQL_ID = v$sql.SQL_ID and v$sql.is_obsolete = 'N' and v$sql.address = vp.address and v$sql.child_number=0) order by id;

-- 分割线
explain plan set statement_id='1641453074999' for select * from table(dbms_xplan.display_cursor('749x052ct6chf'));

-- 分割线
select  * from table(dbms_xplan.display_cursor('5wp4sdhqmmdnz'));

-- 分割线
explain plan set statement_id='1641521234920' for SELECT TIMESTAMP,ID,LPAD(' ', 3*DEPTH,' ') || OPERATION || ' ' || OPTIONS AS TREE_OPERATION,OPERATION,OBJECT_NAME,BYTES,COST,CPU_COST, IO_COST,OBJECT_OWNER, CARDINALITY, OPTIONS, TIME AS TIME_SEC, FILTER_PREDICATES, PLAN_HASH_VALUE AS PLAN_ID FROM V$SQL_PLAN WHERE SQL_ID = :1  AND PLAN_HASH_VALUE = :2  AND HASH_VALUE = :3  ORDER BY TIMESTAMP,id;

-- 分割线
begin
  if :enable = 0 then
    sys.dbms_output.disable;
  else
    sys.dbms_output.enable(:size);
  end if;
end;
;

-- 分割线
explain plan set statement_id='1640934695308' for select * from table(dbms_xplan.display_cursor('at9qcygw7g05p'));

